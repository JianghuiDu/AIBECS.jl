var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"<img src=\"https://user-images.githubusercontent.com/4486578/57189839-c422db00-6f56-11e9-9e1d-26c8d9208702.png\" alt=\"logo\" title=\"AIBECS_logo\" align=\"right\" width=\"200\"/>","category":"page"},{"location":"#AIBECS.jl-1","page":"Home","title":"AIBECS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Algebraic Implicit Biogeochemistry Element-Cycling System","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Work in Progress)","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"AIBECS may be pronounced like the cool ibex (if you have a french accent). AIBECS is a new software written in Julia to easily create some marine biogeochmistry models in just a few commands.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nAIBECS is developed primarily by Benoît Pasquier with the help of François Primeau and J. Keith Moore from the Department of Earth System Science at the University of California, Irvine, USA. This software is in active development, so if you have any suggestions or feature requests, do not hesitate to start an issue directly on the AIBECS GitHub repository!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AIBECS is not just a single model. It's a system that allows you to create a global steady-state biogeochmistry model with just a few simple commands. Basically, you just need to tell AIBECS","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(i) which ocean circulation to use (from simple toy models of just a few boxes to more complicated global models of the circulation),\n(ii) what elements you want to model/track and \n(iii) how each tracer gets converted into other tracers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Once the model is set up, you can run simulations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AIBECS relies on many tools from linear algebra to run simulations and perform optimizations really fast. AIBECS-generated models are described by a state function, denoted boldsymbolF, which defines how the concnetrations of elements in the ocean evolve with time. In mathematical terms, this translates to a system of nonlinear differential equations with the generic form ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"fracpartial boldsymbolxpartial t = boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where boldsymbolx is the state of the model (i.e., the concentrations of the tracers), and boldsymbolp are model parameters. Here, we are interested in the equilibrium of the system (AKA the steady-state). That is when the time-derivative is 0, so that","category":"page"},{"location":"#","page":"Home","title":"Home","text":"boldsymbolF(boldsymbolx boldsymbolp) = 0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and boldsymbolx does not change with time. Instead of simulating the evolution of boldsymbolx with time and waiting for the system to reach equilibrium — like most biogeochemistry models do — AIBECS uses linear algebra techniques, like Newton's method in multiple dimensions, or Krylov spaces, to implicitly solve for the steady-state solution, hence the \"algebraic\" and \"implicit\" names. This makes AIBECS much faster than the competition!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you want to try AIBECS, head over to the prerequisites page to install the packages (this should take you a few minutes), and then open up one of the notebooks!","category":"page"},{"location":"prerequisites/#Prerequisites-1","page":"Prerequisites","title":"Prerequisites","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This section provides a set of instructions and prerequisites to use AIBECS.","category":"page"},{"location":"prerequisites/#.-Install-Julia-1","page":"Prerequisites","title":"1. Install Julia","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"First things first, you must install Julia. Click on the Julia link, look for the \"download\" buttons, and install the correct version for your OS. Once this is done, you should be able to start Julia by typing","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"in the terminal. If not, find the Julia executable, and simply double click on it! This should open a terminal session, and display something like this:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.1.1 (2019-05-16)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This is called the Julia REPL (for Read Eval Loop Print) and is used for interactive use of Julia. Great job, Julia is now running on your computer! Congratulations!","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"If you want to learn more about Julia, you can read the documentation, there is a Discourse forum, and there is a Slack channel if you need help. But for now you should not need any of those: The notebook will just require you to press Shift + Enter a couple of times.","category":"page"},{"location":"prerequisites/#.-Julia-packages-required-for-the-notebooks-1","page":"Prerequisites","title":"2. Julia packages required for the notebooks","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In Julia, you can access the package manager by simply typing ] in the REPL. Once you type ], the REPL changes to","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg>","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This means you're in the package-manager (or pkg) mode.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Note that you can exit the pkg mode by pressing the delete key, and this will revert the Julia prompt to its original form:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia>","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"The packages you should install are:","category":"page"},{"location":"prerequisites/#[AIBECS](https://github.com/briochemc/AIBECS.jl)-1","page":"Prerequisites","title":"AIBECS","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"To create a global steady-state biogeochemistry model, we will be using the AIBECS package. You install it, via","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"add AIBECS","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"in pkg mode, which should look like","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add AIBECS","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This should only take a few seconds.","category":"page"},{"location":"prerequisites/#[Cartopy](https://scitools.org.uk/cartopy/docs/latest/)-1","page":"Prerequisites","title":"Cartopy","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In order to plot things, i.e., to look at the output of the beautiful work you will be doing with AIBECS, you will need a plotting package. For good-looking maps, I suggest using Python's Cartopy because, well, it looks pretty. A few steps are necessary to install it:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Install the Conda package.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In pkg mode, do","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add Conda","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Install Cartopy using Conda (within Julia).","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In REPL mode (i.e., not in pkg mode — press delete to get there from pkg mode), do","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia> using Conda; Conda.add(\"Cartopy\")","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Install PyPlot via","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add PyPlot","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Intall PyCall via","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add PyCall","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This should only take a few seconds as well.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nYou may want to install Cartopy differently, or even use a different plotting package. This is merely a suggestion that has worked well for me.","category":"page"},{"location":"prerequisites/#[IJulia](https://github.com/JuliaLang/IJulia.jl)-1","page":"Prerequisites","title":"IJulia","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"For running the notebooks, I suggest using the IJulia package. Specifically, IJulia allows you to launch JupyterLab from Julia. To install it, in pkg mode, type add IJulia (and press return), and you should see something like:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add IJulia","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This should only take a few seconds as well.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nIJulia is recommended but not mandatory to run the notebooks. You could install JupyterLab outside of Julia and use that instead.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nYou may need to build CodecZlib to run the notebooks. If you see an error mentioning you should build it, then build it! It's easy, just go in pkg mode and type build CodecZlib. It should look like this:(v1.1) pkg> build CodecZlib","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"If you followed all these steps you should be able to use the notebooks!","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"The final step is to start JupyterLab. First, make sure you are in the normal Julia REPL mode (i.e., press delete if you are in pkg mode.) Then, tell Julia that you want to \"use\" IJulia:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia> using IJulia","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nYou can just copy paste the code above (including the julia> bits), and the REPL will know to not paste those automatically. Everytime a package is used for the first time, Julia will precompile it (which can take a few seconds to minutes, depending on the package — don't worry, just let it finish).","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Finally, you can start JupyterLab from Julia by simply typing jupyerlab() in Julia. It should look like:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia> jupyterlab()","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nIf Julia asks you if you want Conda to install JupyterLab, just say \"yes\" (i.e., type y). After a couple seconds/minutes of downloads and installations, you should be all set up and a browser window should open with JupyterLab!","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Just navigate to the notebook of your choice with JupyterLab in your browser and double-click on the notebook!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/ideal_mean_age.jl\"","category":"page"},{"location":"examples/generated/ideal_mean_age/#Ideal-mean-age-1","page":"Ideal mean age","title":"Ideal mean age","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"tip: Tip\nThis example is also available as a Jupyter notebook: ideal_mean_age.ipynb","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-model-1","page":"Ideal mean age","title":"The model","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will simulate the ideal mean age of water. That is, the average amount of time since a water parcel had last contact with the surface.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Tracer-equation-1","page":"Ideal mean age","title":"Tracer equation","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The ideal mean age is transported with water, is equal to 0 at the surface, and increases by one second every second everywhere. In other words, the 3D field of the age, a, is governed by the tracer equation","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartial apartial t = - nabla cdot left boldsymbolu - mathbfK cdot nabla right a + 1","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where nabla cdot left boldsymbolu - mathbfK cdot nabla right is a differential operator that represents the transport by the ocean circulation. (boldsymbolu is the 3D vector field for the advection and mathbfK is the diffusivity matrix.) In the equation above, we also assume that there is the boundary condition that a=0 at the surface.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Discretized-tracer-equation-1","page":"Ideal mean age","title":"Discretized tracer equation","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"In AIBECS, the linear differential operator defined by nabla cdot left boldsymbolu - mathbfK cdot nabla right is approximated by a constant matrix mathbfT when discretizing the continuous 3D ocean onto the model grid. This matrix can be small (e.g., for models with a few boxes), or large, like for the OCIM (more on the OCIM later). Similarly, the continuous 3D field of the age, a, is discretized into a column-vector, boldsymbola. (We represent scalars in italic, vectors in bold italic, and matrices in upstraight bold.)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"In the discrete case, we replace the boundary condition (that a = 0 at the surface) by imposing boldsymbola = 0 in the surface layer of the model grid. In practice, this is done by restoring boldsymbola to 0 with a very short timescale. The tracer equation thgus takes the form of","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartialboldsymbolapartial t = -mathbfT  boldsymbola + 1 - boldsymbola  tau","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where tau will be chosen to be very small, ensuring that boldsymbola is very close to 0 at the surface. The first term represents the transport by the ocean circulation, the second term the source of 1 second per second everywhere, and the last term the fast relaxation.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Steady-state-1","page":"Ideal mean age","title":"Steady-state","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The steady-state is the equilibrium that would be reached if we wait long enough for a to not change anymore. Mathematically, the steady-state is also the state for which","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartial apartial t = 0","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Computationally, in the discrete case, this means that we just need to solve","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"0 = -mathbfT  boldsymbola + 1 - boldsymbola  tau","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"to find boldsymbola. More specifically, we need to solve","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"(mathbfT + mathbfI  tau)  boldsymbola = 1","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Now that we have the equations laid down, let us chose the circulation transport matrix, mathbfT.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Using-AIBECS-1","page":"Ideal mean age","title":"Using AIBECS","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nIf this is the first time you are trying AIBECS, make sure you go through the prerequisites!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"AIBECS can interpret tracer equations as long as you arrange them under the generic form:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartial boldsymbolxpartial t = boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where boldsymbolF(boldsymbolx boldsymbolp) is the rate of change of the state and boldsymbolp is the vector of model parameters. We only track the age here, so that the entire state of the system is determined by the age itself. In other words, here, boldsymbolx = boldsymbola.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will use AIBECS to find the steady-state of the system. For AIBECS, this translates into finding the solution of boldsymbolF(boldsymbolx boldsymbolp) = 0.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We start by telling Julia that we want to use the AIBECS package via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"using AIBECS","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nIf it's the first time you are running this line, the package will need precompiling. This may take a minute or two. (Just be patient... Or read on while you wait!)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nYou should see a Warning for the Flatten package — just disregard it... If you get an error though, please send me a copy of the output/error message, and I will try to troubleshoot it.","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-circulation-1","page":"Ideal mean age","title":"The circulation","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will use the circulation output from the Ocean Circulation Inverse Model (OCIM) version 1.1. Basically, the OCIM provides researchers and oceanographers with a big sparse matrix that represents the global ocean circulation (advection and diffusion), which allows them to efficiently simulate the transport of passive tracers, like the age. (For more details, see Tim DeVries's website and references therein.) With AIBECS, the OCIM circulation can be loaded really easily, by simply typing","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"const wet3d, grd, T_OCIM = AIBECS.OCIM1.load()\ntypeof(T_OCIM), size(T_OCIM)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Here, I have used the const prefix to tell Julia these are constants (it helps Julia's compiler)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nJulia may ask you to download the OCIM matrix for you, in which case you should say yes (i.e., type y). Once downloaded, AIBECS will remember where it downloaded the file and it will only load it from your laptop.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Additionally to downloading the OCIM file, the load() command loads 3 variables in the Julia workspace:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"wet3d — a 3D array of the model grid, filled with 1's at \"wet\" grid boxes and 0's and \"land\" grid boxes.\ngrd — a dictionary containing information about the 3D grid of the OCIM circulation, like the latitude, longitude, and depth of each grid boxes. grd is a dictionary (i.e., a Dict in Julia, which is equivalent to a struct in MATLAB or a dict in python).\nT_OCIM — the transport matrix representing advection and diffusion.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The second line in command above tells you the type and the size of T_OCIM. It is a sparse matrix (CSC just means that it is stored in Compressed Sparse Column format) and is quite big!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nA sparse matrix is just a matrix with very few non-zero entries. Computationally, sparse matrices are stored differently than full matrices to save memory (no need to save all those zeros), and are much faster to use too!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Anyway, this looks good, so let's move on with setting up the model!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We have already loaded the transport matrix, T_OCIM, for the ocean circulation, but we must tell AIBECS that it applies to the age. To do that, we define a function of the parameters (although there are no parameters involved in this case, this is just the way AIBECS works for the moment).","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"T_age(p) = T_OCIM","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"(Functions in Julia can be created in one line, just as above.) That's it for the circulation. Now, let's define the local sources and sinks.","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-local-sources-and-sinks-1","page":"Ideal mean age","title":"The local sources and sinks","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will denote the age, boldsymbola, by the variable age in Julia. (It's good practice to use explicit names!) We need to translate the local sources and sinks in our discretized state function boldsymbolF(boldsymbolx boldsymbolp) into Julia code.","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-source-1","page":"Ideal mean age","title":"The source","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Remember the age increases by 1 second every second and everywhere. So its source function is equal to, well, 1! (seconds per seconds means it is unitless). Let's create the local source function:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"source_age(age, p) = 1","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-sink-1","page":"Ideal mean age","title":"The sink","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Recall that the age must also be 0 at the surface. And that we implement this boundary condition by restoring the age very fast to 0 in the surface layer. This will act as the sink for the age. But first, we need to figure out where \"the surface layer\" is. To do that, AIBECS can generate a number of useful constants for you. (You can see the list of functions by typing varinfo(AIBECS) at the REPL.) Here we will use the vector of grid box depths, z, which AIBECS can generate for us via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"const z = vector_of_depths(wet3d, grd)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"So what is the top layer? Let's investigate what's the minimum depth:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"minimum(z)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The surface layer in the OCIM grid has its center at about 18m depth. We can create a mask of the surface layer via z .< 20. (This will return a vector of 0s and 1s, depending on whether the depth, z, is less than 20.)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nIn Julia (like in MATLAB), placing a dot, ., in front of operators is a convenient way to do element-wise operations.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Then, we implement the local sink by restoring the age to 0 with a timescale τ, via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"function sink_age(age, p)\n    τ = p.τ\n    return age .* (z .< 20) / τ\nend","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nJulia allows you to use unicode for your functions and variables, like for τ.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Here, we have defined a Julia function using the function keyword because the sink is a bit more complicated, so that we needed two lines to define it. The first line unpacks the model parameters, which is just the restoring timescale, τ, in this case. We will chose the value for τ later.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Net-sources-and-sinks-1","page":"Ideal mean age","title":"Net sources and sinks","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The sources minus the sinks are simply defined by","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"sms_age(age, p) = source_age(age, p) .- sink_age(age, p)","category":"page"},{"location":"examples/generated/ideal_mean_age/#Model-parameters-1","page":"Ideal mean age","title":"Model parameters","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We must define the parameters... And AIBECS comes with an API for that!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"t = empty_parameter_table()    # initialize table of parameters\nadd_parameter!(t, :τ, 1u\"s\")   # add the parameter we want (τ = 1s)\ninitialize_Parameters_type(t, \"IdealAgeParameters\")  # Generate the parameter type\nt","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Note, in particular, that we gave our parameter τ a unit. Yes, Julia comes with some nice functionality to deal with units directly! The lines above created a table that contains all the info for generating the parameters vector, boldsymbolp. To generate the parameters in AIBECS we do:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"p₀ = IdealAgeParameters()","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where we have used the constructor IdealAgeParameters, whose name we defined in the previous cell. Here we did not really need to create p₀ as a parameters vector, since it has only one element, τ, in it. However, we are here to learn, and this structure and functionality comes in very handy when one deals with many parameters. (And as you can imagine, having all the parameters in a nice table ready for being used in a publication comes quite handy!)","category":"page"},{"location":"examples/generated/ideal_mean_age/#State-function-and-Jacobian-1","page":"Ideal mean age","title":"State function and Jacobian","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Similarly to p₀, let's create a state x₀ to start with. The vector x₀ will be our initial guess for the state. Let's assume that the age is 1 (seconds) everywhere (as an initial guess):","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"const nb = number_of_wet_boxes(wet3d)  # number of wet boxes\nx₀ = ones(nb)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The first line above defines the number of wet grid boxes, nb. Here, this is also the length of the state vector x, because there is only one tracer, age. In the second line, the ones function creates a vector of 1s of the size you give it (the number of wet grid boxes, nb, here, which we defined as a constant earlier).","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally, the last step for the set up is to define boldsymbolF. Using AIBECS, this is done via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"T_matrices = (T_age,)           # bundles all the transport matrices in a tuple\nsources_minus_sinks = (sms_age,) # bundles all the source-sink functions in a tuple\nF, ∇ₓF = state_function_and_Jacobian(T_matrices, sources_minus_sinks, nb) # generates the state function (and its Jacobian!)\nF(x₀,p₀)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"That's it! We have just created a model of the mean age.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Lines 2 and 3 are just telling AIBECS","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"what transport matrices it should use for the transport of these tracers, and\nand what local sources and sinks should be appplied to these tracers","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nThe (x,) syntax returns a tuple of one element — the comma is necessary because without it, (x) would be just like x with brackets around it. This interface of AIBECS was developed for case with multiple tracers in mind, and might look a bit odd for a single tracer. But in the future, this might be cleaned up to be easier to work with single tracers.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The fourth line creates two functions:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"F — the numerical version of the state function, boldsymbolF, of our model of the mean age, and\n∇ₓF — the Jacobian matrix of the state function, i.e., nabla_boldsymbolxboldsymbolF.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Yes, AIBECS just automatically created an exact derivative of your input, using autodifferentiation via dual numbers. (I'd be very excited to detail how this is implemented here, but it is an entirely different discussion.)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The last line just checks that our generated F works with our initial guess x₀ and parameter vector p₀.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Solving-for-the-steady-state-1","page":"Ideal mean age","title":"Solving for the steady-state","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The Jacobian, ∇ₓF is essential to solving the steady-state equation boldsymbolF(boldsymbolx boldsymbolp) = 0 fast. Specifically, solving boldsymbolF(boldsymbolx boldsymbolp) = 0 is done via Newton's method. By starting from an initial guess, that you will have to provide, it will iterate over this recursion relation","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"boldsymbolx_k+1 = boldsymbolx_k - nabla_boldsymbolxboldsymbolF(boldsymbolx_k boldsymbolp)^-1 boldsymbolF(boldsymbolx_k boldsymbolp)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"until boldsymbolF(boldsymbolx_k boldsymbolp) is sufficiently small. Now I should note that here, our age model is linear in x (or age in our code), so that the solution will be found in a single iteration, or a sinle \"matrix inversion\", as could be seen from our steady-state equation for boldsymbola.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nAIBECS comes with a built-in algorithm and an API to solve for the steady-state, so you don't have to worry about all these details!","category":"page"},{"location":"examples/generated/ideal_mean_age/#Define-the-Steady-state-problem-in-AIBECS-1","page":"Ideal mean age","title":"Define the Steady-state problem in AIBECS","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"First, we create an instance of the steady-state problem, via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"prob = SteadyStateProblem(F, ∇ₓF, x₀, p₀)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where we have simply provided the state function, boldsymbolF, the Jacobian, nabla_boldsymbolxboldsymbolF, the initial guess and the parameters. The SteadyStateProblem function is a standard \"DiffEqBase\" constructor that I have overloaded in my package so that you can easily generate the model here.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Solve-for-the-steady-state-with-AIBECS-1","page":"Ideal mean age","title":"Solve for the steady-state with AIBECS","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally, we can find the solution in litterally one line, via the solve function:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"age = solve(prob, CTKAlg())","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Here, I have provided the solve function with two things:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"the problem, prob, which we just defined, and\nthe quasi-Newton algorithm that I wrote in Julia, denoted by CTKAlg() after C.T. Kelley, who originally wrote it in MATLAB.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The last line should take about 10 seconds to 1 minute, depending on your laptop. That's it! We solved for the steady state! Everyone here deserves a nice tap on the shoulder — Good job! Now let's see what this age looks like on a map","category":"page"},{"location":"examples/generated/ideal_mean_age/#Figures-1","page":"Ideal mean age","title":"Figures","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will plot a horizontal slice of the age at about 1000m depth using Cartopy.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"First, we must rearrange age into the 3D model grid. For that we will need the vector of the indices of wet points in the 3D grid, which we will denote by iwet, and which AIBECS generates via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"const iwet = indices_of_wet_boxes(wet3d)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We then rearrange the column vector age into a 3D array via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"age_3D = NaN * wet3d # creates a 3D array of NaNs of the same size as `wet3d`\nage_3D[iwet] = age   # Fills the wet grid boxes with the age values\nsize(age_3D)         # Just to check the size of age_3D","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The last line just shows you the size of age_3D, which is a 3D-array as expected.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Now let us find the index of the depth that is closest to 1000m. To do that we must use the depth information contained in grd. Let us first create a small vector of the depths of the grid:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"depth = vec(grd[\"zt\"])","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We could count the index of the entry we want, but here we will use the findfirst function to find the first depth index that is greater than 1000m.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"iz = findfirst(depth .> 1000)\niz, depth[iz]","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We get iz = 13, which is a layer that lies at 1104m, close to 1000m like we wanted.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally, we need the latitude and longitudes of the grid, contained in grd. As for depth, we can use the OCIM's grd output:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"lat, lon = vec(grd[\"yt\"]), vec(grd[\"xt\"])","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"So these are the latitudes and longitudes of the map we are about to plot.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"A last thing we can do is convert the age from seconds, u\"s\", to years, u\"yr\", because the age is large. This can be done via the Unitful package (loaded automatically by AIBECS).","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"age_3d_1000m_yr = age_3D[:,:,iz] * ustrip(1.0u\"s\" |> u\"yr\")","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally! Let's have a look at this ideal mean age! To make figures, here, we use Cartopy. To use it we simply type","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\"\nusing PyPlot, PyCall","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nThe first line is needed for Mac users. It's a bug that should eventually be resolved, but for now this seems to make it work.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We import cartopy, define a new plot, add some coastlines because they are pretty, and add our slice of age at 1000m depth to it via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"clf()\nccrs = pyimport(\"cartopy.crs\")\nax = subplot(projection=ccrs.Robinson(central_longitude=-155.0))\nax.coastlines()\nlon_cyc = [lon; 360+lon[1]] # making it cyclic for Cartopy\nage_cyc = hcat(age_3d_1000m_yr, age_3d_1000m_yr[:,1])\np = contourf(lon_cyc, lat, age_cyc, levels=0:100:1200, transform=ccrs.PlateCarree(), zorder=-1)\ncolorbar(p, orientation=\"horizontal\")\ngcf() # gets the current figure to display","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"That's it! Good job!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"At 1000m, the age ranges from a few years below deep water formation regions (Wedell Sea, North Atlantic), and reaches a dozen of centuries in the North Pacific! This is pretty good for so little work!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/p_cycle_DIP_DOP_POP.jl\"","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#A-Phosphorus-Cycling-Model-1","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"tip: Tip\nThis example is also available as a Jupyter notebook: p_cycle_DIP_DOP_POP.ipynb","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Tracer-equations-1","page":"A Phosphorus Cycling Model","title":"Tracer equations","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"We consider a simple model for the cycling of phosphorus with 3 state variables consisting of phosphate (PO₄) AKA dissolved inorganic phosphorus (DIP), dissolved organic phosphorus (DOP), and particulate organic phosphorus (POP).","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"The dissolved phases are transported by advection and diffusion whereas the particulate phase sinks rapidly down the water column without any appreciable transport by the circulation.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"The governing equations are:","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t DIP + nabla cdot leftboldsymbolu + mathbfKcdotnabla right DIP = -gamma(DIP) + kappa_mathsfD  DOP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t DOP + nabla cdot leftboldsymbolu + mathbfKcdot nabla right DOP = sigma  gamma(DIP) + kappa_mathsfP  POP - kappa_mathsfD  DOP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"and","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t POP + fracpartialpartial z leftw_mathsfP  POPright = (1-sigma)  gamma(DIP) - kappa_mathsfP  POP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"where boldsymbolu is the fluid velocity and mathbfK is the eddy-diffusion tensor. Thus, nabla cdot left boldsymbolu - mathbfK cdot nabla right is a differential operator that represents the transport by the ocean circulation. The function gamma(DIP) represents the biological uptake of DIP by phytoplankton.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Oxygen participates to this cycle too and satisfies its own tracer equation","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t DO_2 + nabla cdot leftboldsymbolu + mathbfKcdotnabla right DO_2 = -r_mathsfO_2mathsfP  kappa_mathsfD  DOP + boldsymbolLambda(DO_2 - O_2_mathsfsat)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"where Lambda is the air-sea gas exchange operator.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"These tracer equations depend on a number of scalars, that we list below","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Symbol Definition\nw_mathsfP depth dependent particle sinking speed\nsigma fraction of the organic matter production allocated to the dissolved phase\nkappa_mathsfD respiration rate for dissolved organic matter (DOP → DIP)\nkappa_mathsfP dissolution rate for particulate organic matter (POP → DOP)\nr_mathsfO_2mathsfP number of moles of O₂ needed to respire 1 mole of DOP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"using AIBECS","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Load the circulation and grid","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"const wet3d, grd, T_Circulation = OCIM1.load()","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Define useful constants and arrays","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"const iwet = indices_of_wet_boxes(wet3d)\nconst nb = number_of_wet_boxes(wet3d)\nconst v = vector_of_volumes(wet3d, grd)\nconst z = vector_of_depths(wet3d, grd)\nconst ztop = vector_of_top_depths(wet3d, grd)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"And matrices","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"const DIV = buildDIV(wet3d, iwet, grd)\nconst Iabove = buildIabove(wet3d, iwet) ;","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Transport-matrices-1","page":"A Phosphorus Cycling Model","title":"Transport matrices","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"T_DIP(p) = T_Circulation\nT_DOP(p) = T_Circulation\nT_DO2(p) = T_Circulation\nconst S₀ = buildPFD(ones(nb), DIV, Iabove)\nconst S′ = buildPFD(ztop, DIV, Iabove)\nfunction T_POP(p)\n    w₀, w′ = p.w₀, p.w′\n    return w₀ * S₀ + w′ * S′\nend\nT_all = (T_DIP, T_DOP, T_POP, T_DO2)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Because AIBECS will solve for the steady state solution directly without time-stepping the goverining equations to equilibrium, we don't have any opportunity to specify any intial conditions. Initial conditions are how the total amount of conserved elements get specified in most global biogeochemical modelels. Thus to specify the total inventory of P in AIBECS we add a very weak resporing term to the DIP equation. The time-scale for this restoring term is chosen to be very long compared to the timescale with which the ocean circulation homogenizes a tracer. Because of this long timescale we call it the geological restoring term, but geochemists who work on geological processes don't like that name! In any event the long timescale allows us to prescribe the total inventory of P without having any appreciable impact on the 3d distribution of P.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Sources-minus-sinks-1","page":"A Phosphorus Cycling Model","title":"Sources minus sinks","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Geological-Restoring-1","page":"A Phosphorus Cycling Model","title":"Geological Restoring","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function geores(x, p)\n    τg, xgeo = p.τg, p.xgeo\n    return (xgeo .- x) / τg\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Uptake-of-phosphate-(DIP)-1","page":"A Phosphorus Cycling Model","title":"Uptake of phosphate (DIP)","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"relu(x) = (x .≥ 0) .* x\nfunction uptake(DIP, p)\n    τu, ku, z₀ = p.τu, p.ku, p.z₀\n    DIP⁺ = relu(DIP)\n    return 1/τu * DIP⁺.^2 ./ (DIP⁺ .+ ku) .* (z .≤ z₀)\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Remineralization-DOP-into-DIP-1","page":"A Phosphorus Cycling Model","title":"Remineralization DOP into DIP","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function remineralization(DOP, p)\n    κDOP = p.κDOP\n    return κDOP * DOP\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Dissolution-of-POP-into-DOP-1","page":"A Phosphorus Cycling Model","title":"Dissolution of POP into DOP","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function dissolution(POP, p)\n    κPOP = p.κPOP\n    return κPOP * POP\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Air-sea-gas-exchange-1","page":"A Phosphorus Cycling Model","title":"Air-sea gas exchange","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"dz1 = grd[\"dzt\"][1]               # thickness of the top layer\nz = vec(grd[\"ZT3d\"])[iwet]        # depth of the gridbox centers\nusing WorldOceanAtlasTools\nWOA = WorldOceanAtlasTools\nμDO2 , σ²DO2 = WOA.fit_to_grid(grd,2018,\"O2sat\",\"annual\",\"1°\",\"an\")","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"This below was commented out?","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function airsea(DO2, p)\n    κDO2 = p.κDO2\n    return κDO2 * (z .< 20) .* (1.0 .- DO2) / dz1\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Add them up into sms functions (Sources Minus Sinks)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function sms_DIP(DIP, DOP, POP, p)\n    return -uptake(DIP, p) + remineralization(DOP, p) + geores(DIP, p)\nend\nfunction sms_DOP(DIP, DOP, POP, p)\n    σ = p.σ\n    return σ * uptake(DIP, p) - remineralization(DOP, p) + dissolution(POP, p)\nend\nfunction sms_POP(DIP, DOP, POP, p)\n    σ = p.σ\n    return (1 - σ) * uptake(DIP, p) - dissolution(POP, p)\nend\nsms_all = (sms_DIP, sms_DOP, sms_POP) # bundles all the source-sink functions in a tuple","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Parameters-1","page":"A Phosphorus Cycling Model","title":"Parameters","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Build the parameters type and p₀","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"t = empty_parameter_table()    # initialize table of parameters\nadd_parameter!(t, :xgeo, 2.17u\"mmol/m^3\",\n    variance_obs = ustrip(upreferred(0.1 * 2.17u\"mmol/m^3\"))^2,\n    description = \"Geological mean P concentration\",\n    LaTeX = \"\\\\state^\\\\mathrm{geo}\")\nadd_parameter!(t, :τg, 1.0u\"Myr\",\n    description = \"Geological restoring timescale\",\n    LaTeX = \"\\\\tau_\\\\mathrm{geo}\")\nadd_parameter!(t, :ku, 10.0u\"μmol/m^3\",\n    optimizable = true,\n    description = \"Half-saturation constant (Michaelis-Menten)\",\n    LaTeX = \"k_\\\\vec{u}\")\nadd_parameter!(t, :z₀, 80.0u\"m\",\n    description = \"Depth of the euphotic layer base\",\n    LaTeX = \"z_0\")\nadd_parameter!(t, :w₀, 1.0u\"m/d\",\n    optimizable = true,\n    description = \"Sinking velocity at surface\",\n    LaTeX = \"w_0\")\nadd_parameter!(t, :w′, 1/4.4625u\"d\",\n    optimizable = true,\n    description = \"Vertical gradient of sinking velocity\",\n    LaTeX = \"w'\")\nadd_parameter!(t, :κDOP, 1/0.25u\"yr\",\n    optimizable = true,\n    description = \"Remineralization rate constant (DOP to DIP)\",\n    LaTeX = \"\\\\kappa\")\nadd_parameter!(t, :κPOP, 1/5.25u\"d\",\n    optimizable = true,\n    description = \"Dissolution rate constant (POP to DOP)\",\n    LaTeX = \"\\\\kappa\")\nadd_parameter!(t, :σ, 0.3u\"1\",\n    description = \"Fraction of quick local uptake recycling\",\n    LaTeX = \"\\\\sigma\")\nadd_parameter!(t, :τu, 30.0u\"d\",\n    optimizable = true,\n    description = \"Maximum uptake rate timescale\",\n    LaTeX = \"\\\\tau_\\\\vec{u}\")\ninitialize_Parameters_type(t, \"Pcycle_Parameters\")   # Generate the parameter type","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Generate-state-function-and-Jacobian-1","page":"A Phosphorus Cycling Model","title":"Generate state function and Jacobian","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"nt = length(T_all)    # number of tracers\nn = nt * nb           # total dimension of the state vector\np = Pcycle_Parameters() # parameters\nx = p.xgeo * ones(n) # initial iterate","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"F, ∇ₓF = statefunctionandJacobian(Tall, sms_all, nb)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"and solve","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p) s = solve(prob, CTKAlg());","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"unpack state","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function unpackPstate(s,mask)         DIP = NaNmask; DOP = NaNmask; POP = NaN*mask         iwet = findall(x-> x==1, vec(mask))         nwet = length(iwet)         idip = 1:nwet;       idop = idip.+nwet;   ipop = idop.+nwet         DIP[iwet] = s[idip]; DOP[iwet] = s[idop]; POP[iwet] = s[ipop]     return DIP, DOP, POP end DIP, DOP, POP = unpackPstate(s,wet3d);","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"We will plot the concentration of DIP at a given depth horizon","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"depth = vec(grd[\"zt\"])\niz = findfirst(depth .> 200)\niz, depth[iz]","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"dip = DIP[:,:,iz] * ustrip(1.0u\"mol/m^3\"|>u\"mmol/m^3\"); lat, lon = vec(grd[\"yt\"]), vec(grd[\"xt\"]);","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"and plot","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\" using PyPlot, PyCall using Conda; Conda.add(\"Cartopy\") clf() ccrs = pyimport(\"cartopy.crs\") ax = subplot(projection=ccrs.Robinson(central_longitude=-155.0)) ax.coastlines()","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#making-it-cyclic-for-Cartopy-1","page":"A Phosphorus Cycling Model","title":"making it cyclic for Cartopy","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"loncyc = [lon; 360+lon[1]] dipcyc = hcat(dip, dip[:,1])","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#And-plot-1","page":"A Phosphorus Cycling Model","title":"And plot","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"p = contourf(loncyc, lat, dipcyc, levels=0:0.2:3.6, transform=ccrs.PlateCarree(), zorder=-1) colorbar(p, orientation=\"horizontal\"); gcf()","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/radiocarbon_OCIM.jl\"","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Radiocarbon-with-OCIM-1","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"tip: Tip\nThis example is also available as a Jupyter notebook: radiocarbon_OCIM.ipynb","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"using AIBECS\nt = empty_parameter_table()               # initialize table of parameters\nadd_parameter!(t, :λ, 1 / (5730*log(2))u\"yr\") # add the radioactive decay e-folding timescale\nadd_parameter!(t, :κ, 50u\"m\" / 10u\"yr\")\ninitialize_Parameters_type(t, \"C14_OCIM_Parameters\")\nt","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"We generate the parameters via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"p = C14_OCIM_Parameters()","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"We load the OCIM matrix via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"const mask, grd, T_OCIM = OCIM1.load()\nT¹⁴C(p) = T_OCIM\niwet = indices_of_wet_boxes(mask);  # index to wet gridboxes","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"and some useful constants","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"dz1 = grd[\"dzt\"][1]               # thickness of the top layer\nz = vector_of_depths(mask, grd)\nnb = number_of_wet_boxes(mask)","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"source minus sinks","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"function SMS¹⁴C(R, p) # source minus sink of age\n    λ = p.λ\n    κ = p.κ\n    return κ * (z .< 20) .* (1.0 .- R) / dz1 - λ.*R\nend","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"Generate state function and Jacobian","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"x = ones(nb)\nTs = (T¹⁴C,)           # bundles all the transport matrices in a tuple\nSMSs = (SMS¹⁴C,) # bundles all the source-sink functions in a tuple\nF, ∇ₓF = state_function_and_Jacobian(Ts, SMSs, nb) # generates the state function (and its Jacobian!)\nF(x,p) # to check it works","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"Set up the problem in AIBECS","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p)\nR = solve(prob, CTKAlg())\nC14_age = -log.(R) / p.λ;","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"Now we plot","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"lat, lon = vec(grd[\"yt\"]), vec(grd[\"xt\"]);\nC14_age_3d = NaN * mask     # creates a 3D array of NaNs\nC14_age_3d[iwet] = C14_age   # Fills the wet grid boxes with the age values\nsize(C14_age)            # Just to check the size","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"Chose the depth index of the slice we want to plot","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"depth = vec(grd[\"zt\"])\niz = findfirst(depth .> 700)\niz, depth[iz]","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"get slice and convert to years","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"C14_age_3d_1000m_yr = C14_age_3d[:,:,iz] * ustrip(1.0u\"s\" |> u\"yr\")","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"and plot","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\"\nusing PyPlot, PyCall\nclf()\nccrs = pyimport(\"cartopy.crs\")\nax = subplot(projection=ccrs.Robinson(central_longitude=-155.0))\nax.coastlines()\nlon_cyc = [lon; 360+lon[1]] # making it cyclic for Cartopy\nage_cyc = hcat(C14_age_3d_1000m_yr, C14_age_3d_1000m_yr[:,1])\np = contourf(lon_cyc, lat, age_cyc, levels=0:100:3600, transform=ccrs.PlateCarree(), zorder=-1)\ncolorbar(p, orientation=\"horizontal\")\ngcf()","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM","title":"Radiocarbon with OCIM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/tracer_transport_operators.jl\"","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Tracer-Transport-Operators-1","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"tip: Tip\nThis example is also available as a Jupyter notebook: tracer_transport_operators.ipynb","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"To model marine biogeochemical processes on a global scale we need to be able to account for the movement of chemical constituents both horizontally and vertically. We do this with a tracer transport operator. When this operator acts on a tracer field it produces the advective-diffusive divergence of the tracer.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Discretization-1","page":"Tracer Transport Operators","title":"Discretization","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"In order to represent the transport operator on a computer we have to discretize the tracer concentration field and the operator. Once discretized the tracer field is represented as a vector and the operator is represented as a sparse matrix.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"note: Note\nA sparse matrix behaves the same way as a regular matrix. The only difference is that in a sparse matrix the majority of the entries are zeros. These zeros are not stored explicitly to save computer memory making it possible to deal with fairly high resolution ocean models.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Mathematically, the discretization converts an expression with partial derivatives into a matrix vector product:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"nabla cdot left boldsymbolu - mathbfK cdot nabla right C longrightarrow mathbfT  boldsymbolC","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where mathbfT is the flux divergence transport matrix and boldsymbolC is the tracer concentration vector.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"One can go a long way towards understanding what a tracer transport operator is by playing with a simple box model. We therefore introuce a simple box model before moving on to the Ocean Circulation Inverse Model (OCIM).","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The simple box model we consider is embeded in a 2×2×2 \"shoebox\". It has 5 wet boxes and 3 dry boxes, as illustrated below:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"<img src=\"https://user-images.githubusercontent.com/4486578/58314610-3b130b80-7e53-11e9-9fe8-9527cdcca2d0.png\" width =800>","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The circulation consists of","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"a meridional overturning circulation flowing in a cycle through boxes 1 → 2 → 6 → 5 → 1 (shown in the \"meridional section 1\" panel above)\na zonal current in a reentrant cycling through boxes 1 → 3 → 1 (shown in the \"layer 1\" panel above)\nvertical mixing representing deep convection between boxes 2 ↔ 6 (not shown)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#The-transport-matrix-1","page":"Tracer Transport Operators","title":"The transport matrix","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We start by defining the model boxes, theirs volumes, their indices, and so on:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"a = 6367e3   # Earth radius           (m)\nA = 4*pi*a^2 # Earth surface area     (m²)\nd = 3700     # ocean depth            (m)\nV = 0.75*A*d # volume of ocean        (m³)\nh = 200      # thickness of top layer (m)\n\ndz = [h*ones(4,1);(d-h)*ones(4,1)] # grid box thicknesses       (m)\ndV = (dz/d).*((V/4)*ones(8,1))     # grid box volumes           (m³)\ndAz = dV./dz                       # area of face ⟂ to z axis   (m²)\ndy = sqrt.(dAz)                    # north-south side length    (m)\ndx = sqrt.(dAz)                    # east-west side length      (m)\ndAx = dV./dy                       # area of face ⟂ to x axis   (m²)\ndAy = dV./dx                       # area of face ⟂ to y axis   (m²)\n\nmsk = [1, 1, 1, 0, 1, 1, 0, 0]     # wet-dry mask wet=1 dry = 0\niwet = findall(x -> x == 1, msk)        # index to wet gridboxes\nidry = findall(x -> x == 0, msk)        # index to dry gridboxes\nsrf = [1, 1, 1, 0, 0]              # surface mask srface=1 bottom = 0\nisrf = findall(x -> x == 1, srf) ;\niwet","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"As you can see, iwet is the the vector of indices of the wet boxes.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"note: Note\nJulia comes with Unitful, a package for using units, which AIBECS uses. In the examples where we use AIBECS, we will use Unitful.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We now create the transport matrix as the flux divergence of the dissolved tracer transport due to the ocean circulation:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"using LinearAlgebra\nusing SparseArrays\nTRdiv = spzeros(8,8)\nACC = 100e6  # (m³/s) ACC for Antarctic Circumpoloar Current\nTRdiv += sparse([1,1], [1,3], dV[1] \\ [ACC, -ACC], 8, 8)\nTRdiv += sparse([3,3], [3,1], dV[3] \\ [ACC, -ACC], 8, 8)\nMOC = 15e6    # (m³/s) MOC for Meridional Overturning Circulation\nTRdiv += sparse([1,1], [1,5], dV[1] \\ [MOC, -MOC], 8, 8)\nTRdiv += sparse([2,2], [2,1], dV[2] \\ [MOC, -MOC], 8, 8)\nTRdiv += sparse([5,5], [5,6], dV[5] \\ [MOC, -MOC], 8, 8)\nTRdiv += sparse([6,6], [6,2], dV[6] \\ [MOC, -MOC], 8, 8)\nMIX = 10e6      # (m³/s) MIX for vertical mixing at high northern latitudes\nTRdiv += sparse([2,2], [2,6], dV[2] \\ [MIX, -MIX], 8, 8)\nTRdiv += sparse([6,6], [6,2], dV[6] \\ [MIX, -MIX], 8, 8)\nTRdiv = TRdiv[iwet,iwet]\nMatrix(TRdiv)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#From-Equation-to-Code-1","page":"Tracer Transport Operators","title":"From Equation to Code","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Radiocarbon, ¹⁴C, is produced by cosmic rays in the lower stratosphere and upper troposphere. It quickly reacts with oxygen to produce ¹⁴CO₂, which is then mixed throughout the troposphere and enters the ocean through air-sea gas exchange. Because the halflife of radiocarbon is only 5730 years a significant amount of deday can occur before the dissolved inorganic radiocarbon (DI¹⁴C) can mix uniformally throughout the ocean. As such the ¹⁴C serves as a tracer label for water that was recently in contact with the atmosphere.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Tracer-Equation-1","page":"Tracer Transport Operators","title":"Tracer Equation","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Mathematically, the ¹⁴C tracer concentration, denoted R (for Radiocarbon), satisfies the following tracer equation:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"fracpartial Rpartial t = - nabla cdot left boldsymbolu - mathbfK cdot nabla right R + Lambda(R - ^14C_mathsfatm) - kappa R","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The discretized tracer is thus given by","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"fracpartial boldsymbolRpartial t = - mathbfT boldsymbolR + Lambda(boldsymbolR - ^14C_mathsfatm) - kappa boldsymbolR","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We can rearrange that equation as","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"fracdRdt + leftmathbfT+lambdamathbfI+kappaboldsymbolLambdarightR = boldsymbols","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where boldsymbols = kappaboldsymbolLambdaboldsymbol1 effectively acts as a fixed source of Radiocarbon from the atmosphere.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Translation-to-Julia-Code-1","page":"Tracer Transport Operators","title":"Translation to Julia Code","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Here we will perform an idealized radiocarbon simulation in our model and use TRdiv for the transport matrix mathbfT. In this model we prescribe the atmospheric concentration to 1 (unit?) and model the air-sea gas exchange using a constant piston velocity kappa of 50m / 10years. For the radioactive decay we use a timescale tau of (5730 years) / log(2).","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"sec_per_year = 365*24*60*60\nκ = 50 / 10sec_per_year     # m/s\nλ  = 1 / (5730sec_per_year / log(2)); # 1/s","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Λ = sparse(Diagonal(srf)) / h         # air-sea loss operator\nM = TRdiv + κ * Λ + λ * I","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"s = κ * Λ * ones(5);             # air-sea source rate","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Simulating-Radiocarbon-1","page":"Tracer Transport Operators","title":"Simulating Radiocarbon","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"One way to see how the tracer evolves with time is to time step it. Here we will use a simple Euler-backward scheme. That is, below we create a function to solve dxdt = F(x) from tspan[1] to tspan[2] subject to x[tspan[1]] = x0 using the Euler-backward scheme with n timesteps. Note that (x[i+1]-x[i])/dt = J*X[i+1] + s.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"function euler_backward(J, s, tspan, x0, n)\n    dt = (tspan[2] - tspan[1]) / (n - 1)\n    A = I - dt * J\n    X = zeros(5, n)\n    T = zeros(n)\n    X[:,1] .= x0\n    T[1] = tspan[1]\n    for i in 2:n\n        X[:,i] .= A \\ (X[:,i-1] + dt * s)\n        T[i] = T[i-1] + dt\n    end\n    return X, T\nend","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"tspan = [0, 7500]\nx0 = ones(5)\nX, T = euler_backward(-sec_per_year * M, sec_per_year * s, tspan, x0, 10000)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"using PyPlot\nclf()\nc14age = -log.(X) ./ (λ * sec_per_year)\nplot(T, c14age')\nxlabel(\"simulation time (years)\")\nylabel(\"¹⁴C age (years)\")\nlegend(\"box \" .* string.(iwet))\ntitle(\"Simulation of the evolution of ¹⁴C age with Euler-backward time steps\")\ngcf();","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The box model took more than 4000 years to spin up to equilibrium. For a box model that's no big deal because it is not computationally expensive to run the model, but for a big circulation model waiting for the model to spinup is painful. We therefore want a better way to find the equilibrium solution.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Solving-for-the-Steady-State-1","page":"Tracer Transport Operators","title":"Solving for the Steady State","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"One thing we notice is that when the model is at equilibrium, the dRdt term vanishes and the steady state solution is given by the solution to the following linear system of equations","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"underbraceleftmathbfT+lambdamathbfI+kappaboldsymbolLambdaright_mathbfMR = underbracekappaboldsymbolLambdamathbf1_s","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"which can be solved by directly inverting the M matrix.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"R = M \\ s","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"c14age_steady_state = -log.(R) / (λ * sec_per_year)\nfor i in 1:5\n    println(\"box $(iwet[i]): $(round(c14age_steady_state[i])) years\")\nend","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"These are exactly the limit that the Radiocarbon age reaches after about 4000 years of simulation! Try modifying the strength of the currents of the high latitude convective mixing to see how it affects the ¹⁴C-ages.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/#AIBECS-functions-1","page":"Function index","title":"AIBECS functions","text":"","category":"section"},{"location":"functions/#","page":"Function index","title":"Function index","text":"OCIM1.load\nvector_of_depths\nnumber_of_wet_boxes\nindices_of_wet_boxes\nempty_parameter_table\nadd_parameter!\ninitialize_Parameters_type\nstate_function_and_Jacobian\nSteadyStateProblem\nsolve","category":"page"},{"location":"functions/#AIBECS.OCIM1.load","page":"Function index","title":"AIBECS.OCIM1.load","text":"load\n\nReturns wet3d, grd, and T (in that order) from FigShare repository.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.GridTools.vector_of_depths","page":"Function index","title":"AIBECS.GridTools.vector_of_depths","text":"vector_of_depths(wet3d, grd)\n\nReturns the vector of depths of the center of wet boxes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.GridTools.number_of_wet_boxes","page":"Function index","title":"AIBECS.GridTools.number_of_wet_boxes","text":"number_of_wet_boxes(wet3d)\n\nReturns the number of wet grid boxes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.GridTools.indices_of_wet_boxes","page":"Function index","title":"AIBECS.GridTools.indices_of_wet_boxes","text":"indices_of_wet_boxes(wet3d)\n\nReturns the vector of the indices of wet grid boxes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.add_parameter!","page":"Function index","title":"AIBECS.add_parameter!","text":"add_parameter!(t::DataFrame, args...; kwargs...)\n\nAdds a parameter to the parameters table t. If keyword argument optimizable = false, then observation mean and variance are set to NaN. Otherwise, these are set to keyword arguments mean_obs (and variance_obs) if supplied, or to quantity (and its square), after converting it to the preferred unit and stripping it of said unit if not. Example: TODO Note for future edit of the docs: Don't repeat yourself between add and new param functions\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.initialize_Parameters_type","page":"Function index","title":"AIBECS.initialize_Parameters_type","text":"initialize_Parameters_type(t, PName=\"Parameters\")\n\nGenerate the type called after PName and all its functionality with it. It is recommended to use upper camel case for PName as for all user-defined Julia types. PName defaults to \"Parameters\".\n\nFor example, use\n\njulia> initialize_Parameters_type(t) # creates Parameters\n\nor\n\njulia> initialize_Parameters_type(t, \"MyPara\") # creates MyPara\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.state_function_and_Jacobian","page":"Function index","title":"AIBECS.state_function_and_Jacobian","text":"F, ∇ₓF = state_function_and_Jacobian(Ts, Gs, nb)\n\nReturns the state function F and its jacobian, ∇ₓF.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DiffEqBase.SteadyStateProblem","page":"Function index","title":"DiffEqBase.SteadyStateProblem","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p)\n\nReturns the SteadyStateProblem defined by F(x,p)=0.\n\n\n\n\n\n","category":"type"}]
}
