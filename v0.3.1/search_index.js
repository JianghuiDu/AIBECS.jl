var documenterSearchIndex = {"docs":
[{"location":"functions/#AIBECS-functions-1","page":"Function index","title":"AIBECS functions","text":"","category":"section"},{"location":"functions/#","page":"Function index","title":"Function index","text":"OCIM1.load\nvector_of_depths\nnumber_of_wet_boxes\nindices_of_wet_boxes\nempty_parameter_table\nadd_parameter!\ninitialize_Parameters_type\nstate_function_and_Jacobian\nSteadyStateProblem\nsolve","category":"page"},{"location":"functions/#AIBECS.OCIM1.load","page":"Function index","title":"AIBECS.OCIM1.load","text":"load\n\nReturns grd and T (in that order) from FigShare repository.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.GridTools.vector_of_depths","page":"Function index","title":"AIBECS.GridTools.vector_of_depths","text":"vector_of_depths(grid)\n\nReturns the vector of depths of the center of wet boxes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.GridTools.number_of_wet_boxes","page":"Function index","title":"AIBECS.GridTools.number_of_wet_boxes","text":"number_of_wet_boxes(wet3D::BitArray)\n\nReturns the number of wet grid boxes.\n\n\n\n\n\nnumber_of_wet_boxes(grid)\n\nReturns the number of wet grid boxes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.GridTools.indices_of_wet_boxes","page":"Function index","title":"AIBECS.GridTools.indices_of_wet_boxes","text":"indices_of_wet_boxes(wet3D::BitArray)\n\nReturns the vector of the indices of wet grid boxes.\n\n\n\n\n\nindices_of_wet_boxes(grid)\n\nReturns the vector of the indices of wet grid boxes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.add_parameter!","page":"Function index","title":"AIBECS.add_parameter!","text":"add_parameter!(t::DataFrame, args...; kwargs...)\n\nAdds a parameter to the parameters table t. If keyword argument optimizable = false, then observation mean and variance are set to NaN. Otherwise, these are set to keyword arguments mean_obs (and variance_obs) if supplied, or to quantity (and its square), after converting it to the preferred unit and stripping it of said unit if not. Example: TODO Note for future edit of the docs: Don't repeat yourself between add and new param functions\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.initialize_Parameters_type","page":"Function index","title":"AIBECS.initialize_Parameters_type","text":"initialize_Parameters_type(t, PName=\"Parameters\")\n\nGenerate the type called after PName and all its functionality with it. It is recommended to use upper camel case for PName as for all user-defined Julia types. PName defaults to \"Parameters\".\n\nFor example, use\n\njulia> initialize_Parameters_type(t) # creates Parameters\n\nor\n\njulia> initialize_Parameters_type(t, \"MyPara\") # creates MyPara\n\n\n\n\n\n","category":"function"},{"location":"functions/#AIBECS.state_function_and_Jacobian","page":"Function index","title":"AIBECS.state_function_and_Jacobian","text":"F, ∇ₓF = state_function_and_Jacobian(Ts, Gs, nb)\n\nReturns the state function F and its jacobian, ∇ₓF.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DiffEqBase.SteadyStateProblem","page":"Function index","title":"DiffEqBase.SteadyStateProblem","text":"SteadyStateProblem(F, ∇ₓF, x, p)\n\nReturns the SteadyStateProblem defined by F(x,p)=0.\n\n\n\n\n\n","category":"type"},{"location":"functions/#DiffEqBase.solve","page":"Function index","title":"DiffEqBase.solve","text":"solve(prob::DiffEqBase.AbstractSteadyStateProblem,\n      alg::CTKAlg;\n      nrm=norm,\n      τstop=1e12*365*24*60*60,\n      preprint=\"\",\n      maxItNewton=50)\n\nSolves prob using the modified C.T.Kelley Shamanskii algorithm.\n\n\n\n\n\n","category":"function"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/tracer_transport_operators.jl\"","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Tracer-Transport-Operators-1","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"tip: Tip\nThis example is also available as a Jupyter notebook: tracer_transport_operators.ipynb","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"To model marine biogeochemical processes on a global scale we need to be able to account for the movement of chemical constituents both horizontally and vertically. We do this with a tracer transport operator. When this operator acts on a tracer field it produces the advective-diffusive divergence of the tracer.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Discretization-1","page":"Tracer Transport Operators","title":"Discretization","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"In order to represent the transport operator on a computer one needs to discretize the tracer concentration field and the operator. Once discretized the tracer field is represented as a vector and the operator is represented as a sparse matrix.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"note: Note\nA sparse matrix behaves the same way as a regular matrix. The only difference is that in a sparse matrix the majority of the entries are zeros. These zeros are not stored explicitly to save computer memory making it possible to deal with fairly high resolution ocean models.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Mathematically, the discretization converts an expression with partial derivatives into a matrix vector product. For the ocean circulation, we do the following conversion","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"nabla cdot left boldsymbolu - mathbfK cdot nabla right C longrightarrow mathbfT  boldsymbolC","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where C(boldsymbolr) is a tracer concentration at location boldsymbolr. (We often omit the boldsymbolr dependency in equations for brevity.) The nabla cdot left boldsymbolu - mathbfK cdot nabla right C term is the flux divergence of the tracer due to the marine currents and turbulent eddies. (boldsymbolu is the 3D current velocity and mathbfK the diffusivity matrix.) The matrix mathbfT is the flux divergence transport matrix and boldsymbolC is the tracer concentration vector.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"One can go a long way towards understanding what a tracer transport operator is by playing with a simple model with only a few boxes, which is the goal of this example.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The simple box model we consider is embeded in a 2×2×2 \"shoebox\". It has 5 wet boxes and 3 dry boxes, as illustrated below:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"<img src=\"https://user-images.githubusercontent.com/4486578/58314610-3b130b80-7e53-11e9-9fe8-9527cdcca2d0.png\" width =800>","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The circulation consists of","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"a meridional overturning circulation flowing in a cycle through boxes 1 → 2 → 6 → 5 → 1 (shown in the \"meridional section 1\" panel above)\na zonal current in a reentrant cycling through boxes 1 → 3 → 1 (shown in the \"layer 1\" panel above)\nvertical mixing representing deep convection between boxes 2 ↔ 6 (not shown)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#The-model-grid-and-the-transport-matrix-1","page":"Tracer Transport Operators","title":"The model grid and the transport matrix","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Like for any models using AIBECS, we start by telling Julia just that:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"using AIBECS","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We then load the shoebox model via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"grd, T = Primeau_2x2x2.load() ;","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where we have loaded 2 objects, grd and T.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"grd is an OceanGrid object, of size 2×2×2:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"grd","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"This object is defined in the OceanGrids package, on which AIBECS depends. There are many ways to look inside the grid, one of which is to iterate over it:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"[println(box) for box in grd] ;","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"shows some details about all the boxes of the model, one at a time. The grd object also contains other information about the grid, like the 3D depths of the boxes:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"grd.depth_3D","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"or the 3D latitudes:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"grd.lat_3D","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where you can check that northwards = downwards in the array. You may notice these come with units! This helps ensure that degrees of latitude are not confused with meters for example.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"note: Note\nJulia comes with Unitful, a package for using units, which AIBECS uses.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Inside of grd, there is information of which boxes of the grid are \"wet\" (or \"dry\"). wet3D is a 3D array representing the 3D ocean with true for \"wet\" boxes and false for \"dry\" boxes. Let's have a look at its contents:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"wet3D = grd.wet3D","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"It's a 2×2×2 BitArray, i.e., an array of bit elements (the true and false entries). You can check that it matches our \"shoebox\" model. (Well, except for the orientation, for which northwards in the box model is downwards in the array.)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We can find all the wet boxes simply via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"findall(wet3D)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"These are the 3D indices of the wet boxes, (i,j,k), called the \"cartesian\" indices. If you want the \"linear\" indices, i.e., the numbers as shown in the image of the shoebox model, you can simply transform wet3D into a vector, via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"iwet = findall(vec(wet3D))","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We can also check that we indeed have the expected number of wet boxes via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"nb = length(iwet)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Now let's have a look at the transport matrix T, which represents nabla cdot left boldsymbolu - mathbfK cdot nabla right, i.e., the flux divergence operator for dissolved tracers:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"T","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"It's a sparse matrix (a SparseMatrixCSC object in Julia), which only stores those entries that are not zero. We can display the full matrix via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Matrix(T)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"to check its structure out. Note that all the diagonal terms are positive, which is the sign that the transport matrix acts as a divergence, which would be positive for a box containing all the tracer. For example, if there was only some tracer in box 2, then that tracer should \"diverge\" away from that box, resulting in the positiva value in that box:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"j = 2                            # index where we put some tracer\nx = 1.0 * [i == j for i in 1:nb] # vector of 0's except for index j\nx, (T * x)[j]","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"shows that the flux divergence T * x is positive where we injected the tracer.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Radiocarbon-1","page":"Tracer Transport Operators","title":"Radiocarbon","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Radiocarbon, ¹⁴C, is produced by cosmic rays in the lower stratosphere and upper troposphere. It quickly reacts with oxygen to produce ¹⁴CO₂, which is then mixed throughout the troposphere and enters the ocean through air–sea gas exchange. Because the halflife of radiocarbon is only 5730 years a significant amount of decay can occur before the dissolved inorganic radiocarbon (DI¹⁴C) can mix uniformally throughout the ocean. As such the ¹⁴C serves as a tracer label for water that was recently in contact with the atmosphere.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Tracer-Equation-1","page":"Tracer Transport Operators","title":"Tracer Equation","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Mathematically, the ¹⁴C tracer concentration, denoted R (for Radiocarbon), satisfies the following tracer equation:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"fracpartial Rpartial t + nabla cdot left boldsymbolu - mathbfK cdot nabla right R = Lambda(R_mathsfatm - R) - R  tau","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where Lambda(R_mathsfatm - R) represents the air–sea exchanges and R  tau the radioactive decay rate. (tau is the radioactive decay timescale.)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The discretized tracer is thus given by","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"fracpartial boldsymbolRpartial t + mathbfT  boldsymbolR = mathbfLambda(R_mathsfatm - boldsymbolR) - boldsymbolR  tau","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Translation-to-AIBECS-Code-1","page":"Tracer Transport Operators","title":"Translation to AIBECS Code","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We will perform an idealized radiocarbon simulation in our model and use the ocean circulation defined earlier using AIBECS. In this model we prescribe the atmospheric concentration, R_mathsfatm, to be simply equal to 1. (We do not specify its unit or its specific value because it is not important for determining the age of a water parcel — only the decay rate does.)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"To use AIBECS, one must put the equations into the generic form of","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"fracpartial boldsymbolxpartial t + mathbfT(boldsymbolp)  boldsymbolx = boldsymbolG(boldsymbolx boldsymbolp)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where boldsymbolx is the state vector, boldsymbolp is the vector of model parameters, mathbfT(boldsymbolp) is the transport operator, and boldsymbolG(boldsymbolx boldsymbolp) is the local sources minus sinks.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"In our radiocarbon-model context, with boldsymbolx = boldsymbolR, we have that","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"boldsymbolG(boldsymbolx boldsymbolp) = mathbfLambda(R_mathsfatm - boldsymbolx) - boldsymbolx  tau","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Hence, we must create T(p) and G(x,p) to give AIBECS the means to simulate the tracer distribution and/or its evolution in time.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Sources-and-Sinks-1","page":"Tracer Transport Operators","title":"Sources and Sinks","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The local sources and sinks are thus simply given by","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"function G(x, p)\n    τ, Ratm = p.τ, p.Ratm\n    return Λ(Ratm .- x, p) - x / τ\nend","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where τ is the decay rate timescale and Ratm is the atmospheric concentration of radiocarbon.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We must define the air–sea exchange rate, Λ(x,p), which requires us to define which boxes are located at the surface first. This is done, e.g., via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"surface_boxes = grd.depth_3D[iwet] .== grd.depth[1]","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The air–sea exchange rate is then given by","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"function Λ(x, p)\n    λ, h = p.λ, p.h\n    return λ / h * surface_boxes .* x\nend","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"where λ is the piston velocity and h is the height of the top layer of the model grid.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Parameters-1","page":"Tracer Transport Operators","title":"Parameters","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"For the air–sea gas exchange, we use a constant piston velocity lambda of 50m / 10years, which will happen in the top layer, of height given by, well, the height of the top layer. And for the radioactive decay we use a timescale tau of 5730/log(2) years. We define these as parameters using the dedicated API from the AIBECS:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"t = empty_parameter_table()                   # initialize an empty table of parameters\nadd_parameter!(t, :τ, 5730u\"yr\"/log(2)) # radioactive decay e-folding timescale\nadd_parameter!(t, :λ, 50u\"m\" / 10u\"yr\") # piston velocity\nadd_parameter!(t, :h, grd.δdepth[1])    # height of top layer\nadd_parameter!(t, :Ratm, 1.0u\"mol/m^3\") # atmospheric concentration\nt","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"shows the parameters that you just created.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We now generate a new object to contain all these parameters via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"initialize_Parameters_type(t, \"C14_shoebox_parameters\") # creates the type for parameters\np = C14_shoebox_parameters()                            # creates the parameters object","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Generate-the-state-function-and-its-Jacobian-1","page":"Tracer Transport Operators","title":"Generate the state function and its Jacobian","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The last step for the setup is for AIBECS to create boldsymbolF(boldsymbolx boldsymbolp) = boldsymbolG(boldsymbolx boldsymbolp) - mathbfT(boldsymbolp)  boldsymbolx, which defines the rate of change of the state, boldsymbolx. This is done via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"F, ∇ₓF = state_function_and_Jacobian(p -> T, G) # generates the state function (and its Jacobian!)\nx = zeros(nb)\nF(x,p)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Note here that AIBECS has automatically created ∇ₓF, i.e., nabla_boldsymbolxboldsymbolF(boldsymbolx boldsymbolp), which is the Jacobian of the system. This Jacobian will be useful in the simulations below.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"That's it! Your model is entirely setup and ready to be used for simulations!","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Time-stepping-1","page":"Tracer Transport Operators","title":"Time stepping","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"One way to see how the tracer evolves with time is to time step it. Here we will use the Crank-Nicolson scheme embedded in AIBECS.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"A single step is performed via, e.g.,","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"δt = ustrip(1.0u\"yr\" |> u\"s\")\nAIBECS.crank_nicolson_step(x, p, δt, F, ∇ₓF)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"We can write a function to run all the time steps and save them into a x_hist object, via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"function time_steps(x₀, Δt, n, F, ∇ₓF)\n    x_hist = [x₀]\n    δt = Δt / n\n    for i in 1:n\n        push!(x_hist, AIBECS.crank_nicolson_step(last(x_hist), p, δt, F, ∇ₓF))\n    end\n    return reduce(hcat, x_hist), 0:δt:Δt\nend","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"note: Note\nWe store all the history of x in x_hist. At each step, the push! function adds a new x to x_hist. Technically, x_hist is a vector of vectors, so at the end, we horizontally concatenate it via reduce(hcat, x_hist) to rearrange it into a 2D array.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Now let's simulate the evolution of radiocarbon for 7500 years, starting from a concentration of 1 everywhere, via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Δt = ustrip(7500u\"yr\" |> u\"s\") # 7500 years in seconds\nx₀ = ones(5)             #\nx_hist, t_hist = time_steps(x₀, Δt, 1000, F, ∇ₓF) # runs the simulation","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"This should take a few seconds to run.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"note: Note\nAIBECS also has other time-stepping methods available, including Euler-froward (fast but unstable), Euler-backwards (like Crank-Nicolson, slow but stable), and Crank-Nicolson-Leapfrog (Fast-ish and more stable than Euler forward).","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Once it's done, we can plot the evolution of radiocarbon through time via","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"using PyPlot\nclf()\nC14age_hist = -log.(x_hist) * ustrip(p.τ * u\"s\" |> u\"yr\")\nplot(t_hist * ustrip(1u\"s\" |> u\"yr\"), C14age_hist')\nxlabel(\"simulation time (years)\")\nylabel(\"¹⁴C age (years)\")\nlegend(\"box \" .* string.(iwet))\ntitle(\"Simulation of the evolution of ¹⁴C age with Crank-Nicolson time steps\")\ngcf()","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"The box model took more than 4000 years to spin up to equilibrium. For a box model that's no big deal because it is not computationally expensive to run the model, but for a big circulation model waiting for the model to spinup is painfully long. We therefore want a better way to find the equilibrium solution.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#Solving-Directly-for-the-Steady-State-1","page":"Tracer Transport Operators","title":"Solving Directly for the Steady State","text":"","category":"section"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"With the AIBECS, you can create the steady state problem and solve it in just 2 commands:","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p)\nx_final = solve(prob, CTKAlg()).u","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Converting radiocarbon into years gives the following values","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"C14age_final = -log.(x_final) * p.τ * u\"s\" .|> u\"yr\"\nprintln.(\"box \", iwet, \": \", C14age_final);","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"These are exactly the limit that the Radiocarbon age reaches after about 4000 years of simulation! So what happened there?","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Well, AIBECS used a version of Newton's method to solve for boldsymbolF(boldsymbolx boldsymbolp) = 0. Simply put, Newton's method iterates on the state via the recursion relation","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"boldsymbolx_n+1 = boldsymbolx_n - nabla_boldsymbolxboldsymbolF(boldsymbolx boldsymbolp)^-1 boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"Here, our radiocarbon model only requires a single iteration. This is because the state function, boldsymbolF(boldsymbolx boldsymbolp), is linear.","category":"page"},{"location":"examples/generated/tracer_transport_operators/#","page":"Tracer Transport Operators","title":"Tracer Transport Operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/ideal_mean_age.jl\"","category":"page"},{"location":"examples/generated/ideal_mean_age/#Ideal-mean-age-1","page":"Ideal mean age","title":"Ideal mean age","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"tip: Tip\nThis example is also available as a Jupyter notebook: ideal_mean_age.ipynb","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-model-1","page":"Ideal mean age","title":"The model","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will simulate the ideal mean age of water. That is, the average amount of time since a water parcel had last contact with the surface.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Tracer-equation-1","page":"Ideal mean age","title":"Tracer equation","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The ideal mean age is transported with water, is equal to 0 at the surface, and increases by one second every second everywhere. In other words, the 3D field of the age, a, is governed by the tracer equation","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartial apartial t + nabla cdot left boldsymbolu - mathbfK cdot nabla right a = 1","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where nabla cdot left boldsymbolu - mathbfK cdot nabla right is a differential operator that represents the transport by the ocean circulation. (boldsymbolu is the 3D vector field for the advection and mathbfK is the diffusivity matrix.) In the equation above, we also assume that there is the boundary condition that a=0 at the surface.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Discretized-tracer-equation-1","page":"Ideal mean age","title":"Discretized tracer equation","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"In AIBECS, the linear differential operator defined by nabla cdot left boldsymbolu - mathbfK cdot nabla right is approximated by a constant matrix mathbfT when discretizing the continuous 3D ocean onto the model grid. This matrix can be small (e.g., for models with a few boxes), or large, like for the OCIM (more on the OCIM later). Similarly, the continuous 3D field of the age, a, is discretized into a column-vector, boldsymbola. (We represent scalars in italic, vectors in bold italic, and matrices in upstraight bold.)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"In the discrete case, we replace the boundary condition (that a = 0 at the surface) by imposing boldsymbola = 0 in the surface layer of the model grid. In practice, this is done by restoring boldsymbola to 0 with a very short timescale. The tracer equation thgus takes the form of","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartialboldsymbolapartial t = -mathbfT  boldsymbola + 1 - boldsymbolLambda  boldsymbola","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where boldsymbolLambda is a diagonal matrix with entries equal to 1  tau in the surface layer of the model grid and 0 otherwise. The timescale tau is chosen to be very small, ensuring that boldsymbola is very close to 0 at the surface. The first term represents the transport by the ocean circulation, the second term the source of 1 second per second everywhere, and the last term the fast relaxation.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Steady-state-1","page":"Ideal mean age","title":"Steady-state","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The steady-state is the equilibrium that would be reached if we wait long enough for a to not change anymore. Mathematically, the steady-state is also the state for which","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartial apartial t = 0","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Computationally, in the discrete case, this means that we just need to solve","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"0 = -mathbfT  boldsymbola + 1 - boldsymbolLambda  boldsymbola","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"to find boldsymbola. More specifically, we need to solve","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"(mathbfT + boldsymbolLambda)  boldsymbola = 1","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Now that we have the equations laid down, let us chose the circulation transport matrix, mathbfT.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Using-AIBECS-1","page":"Ideal mean age","title":"Using AIBECS","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nIf this is the first time you are trying AIBECS, make sure you go through the prerequisites!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"AIBECS can interpret tracer equations as long as you arrange them under the generic form:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"fracpartial boldsymbolxpartial t = boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where boldsymbolF(boldsymbolx boldsymbolp) is the rate of change of the state and boldsymbolp is the vector of model parameters. We only track the age here, so that the entire state of the system is determined by the age itself. In other words, here, boldsymbolx = boldsymbola.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will use AIBECS to find the steady-state of the system. For AIBECS, this translates into finding the solution of boldsymbolF(boldsymbolx boldsymbolp) = 0.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We start by telling Julia that we want to use the AIBECS package via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"using AIBECS","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nIf it's the first time you are running this line, the package will need precompiling. This may take a minute or two. (Just be patient... Or read on while you wait!)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nYou should see a Warning for the Flatten package — just disregard it... If you get an error though, please send me a copy of the output/error message, and I will try to troubleshoot it.","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-circulation-1","page":"Ideal mean age","title":"The circulation","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will use the circulation output from the Ocean Circulation Inverse Model (OCIM1). Basically, the OCIM provides researchers and oceanographers with a big sparse matrix that represents the global ocean circulation (advection and diffusion), which allows them to efficiently simulate the transport of passive tracers, like the age. (For more details, see Tim DeVries's website and references therein.) With AIBECS, the OCIM0.1 and OCIM1 circulations can be loaded really easily, by simply typing","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"grd, T_OCIM = AIBECS.OCIM1.load()\ntypeof(T_OCIM), size(T_OCIM)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nJulia may ask you to download the OCIM matrix for you, in which case you should say yes (i.e., type y). Once downloaded, AIBECS will remember where it downloaded the file and it will only load it from your laptop.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Additionally to downloading the OCIM file, the load() command loads 2 variables in the Julia workspace:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"grd — a OceanGrid object containing information about the 3D grid of the OCIM circulation, like the latitude, longitude, and depth of each grid boxes, as well as information on which boxes are \"wet\" or \"dry\".\nT_OCIM — the transport matrix representing advection and diffusion.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The second line in command above tells you the type and the size of T_OCIM. It is a sparse matrix (CSC just means that it is stored in Compressed Sparse Column format) and is quite big!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nA sparse matrix is just a matrix with very few non-zero entries. Computationally, sparse matrices are stored differently than full matrices to save memory (no need to save all those zeros), and are much faster to use too!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Anyway, this looks good, so let's move on with setting up the model!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We have already loaded the transport matrix, T_OCIM, for the ocean circulation, but we must tell AIBECS that it applies to the age. To do that, we define a function of the parameters (although there are no parameters involved in this case, this is just the way AIBECS works for the moment).","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"T_age(p) = T_OCIM","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"(Functions in Julia can be created in one line, just as above.) That's it for the circulation. Now, let's define the local sources and sinks.","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-local-sources-and-sinks-1","page":"Ideal mean age","title":"The local sources and sinks","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will denote the age, boldsymbola, by the variable age in Julia. (It's good practice to use explicit names!) We need to translate the local sources and sinks in our discretized state function boldsymbolF(boldsymbolx boldsymbolp) into Julia code.","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-source-1","page":"Ideal mean age","title":"The source","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Remember the age increases by 1 second every second and everywhere. So its source function is equal to, well, 1! (seconds per seconds means it is unitless). Let's create the local source function:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"source_age(age, p) = 1","category":"page"},{"location":"examples/generated/ideal_mean_age/#The-sink-1","page":"Ideal mean age","title":"The sink","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Recall that the age must also be 0 at the surface. And that we implement this boundary condition by restoring the age very fast to 0 in the surface layer. This will act as the sink for the age. But first, we need to figure out where \"the surface layer\" is. To do that, AIBECS can generate a number of useful constants for you. (You can see the list of functions by typing varinfo(AIBECS) at the REPL.) Here we will use the vector of grid box depths, z, which AIBECS can generate for us via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"z = vector_of_depths(grd)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"So what is the top layer? Let's investigate what's the minimum depth:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"minimum(z)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The surface layer in the OCIM grid has its center at about 18m depth. We can create a mask of the surface layer via z .< 20. (This will return a vector of 0s and 1s, depending on whether the depth, z, is less than 20.)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nIn Julia (like in MATLAB), placing a dot, ., in front of operators is a convenient way to do element-wise operations.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Then, we implement the local sink by restoring the age to 0 with a timescale τ, via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"function sink_age(age, p)\n    τ = p.τ\n    return age .* (z .< 20u\"m\") / τ\nend","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nJulia allows you to use unicode for your functions and variables, like for τ.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Here, we have defined a Julia function using the function keyword because the sink is a bit more complicated, so that we needed two lines to define it. The first line unpacks the model parameters, which is just the restoring timescale, τ, in this case. We will chose the value for τ later.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Net-sources-and-sinks-1","page":"Ideal mean age","title":"Net sources and sinks","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The sources minus the sinks are simply defined by","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"sms_age(age, p) = source_age(age, p) .- sink_age(age, p)","category":"page"},{"location":"examples/generated/ideal_mean_age/#Model-parameters-1","page":"Ideal mean age","title":"Model parameters","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We must define the parameters... And AIBECS comes with an API for that!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"t = empty_parameter_table()    # initialize table of parameters\nadd_parameter!(t, :τ, 1u\"s\")   # add the parameter we want (τ = 1s)\ninitialize_Parameters_type(t, \"IdealAgeParameters\")  # Generate the parameter type\nt","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Note, in particular, that we gave our parameter τ a unit. Yes, Julia comes with some nice functionality to deal with units directly! The lines above created a table that contains all the info for generating the parameters vector, boldsymbolp. To generate the parameters in AIBECS we do:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"p₀ = IdealAgeParameters()","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where we have used the constructor IdealAgeParameters, whose name we defined in the previous cell. Here we did not really need to create p₀ as a parameters vector, since it has only one element, τ, in it. However, we are here to learn, and this structure and functionality comes in very handy when one deals with many parameters. (And as you can imagine, having all the parameters in a nice table ready for being used in a publication comes quite handy!)","category":"page"},{"location":"examples/generated/ideal_mean_age/#State-function-and-Jacobian-1","page":"Ideal mean age","title":"State function and Jacobian","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Similarly to p₀, let's create a state x₀ to start with. The vector x₀ will be our initial guess for the state. Let's assume that the age is 1 (seconds) everywhere (as an initial guess):","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"nb = number_of_wet_boxes(grd)  # number of wet boxes\nx₀ = ones(nb)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The first line above defines the number of wet grid boxes, nb. Here, this is also the length of the state vector x, because there is only one tracer, age. In the second line, the ones function creates a vector of 1s of the size you give it (the number of wet grid boxes, nb, here, which we defined earlier).","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally, the last step for the set up is to define boldsymbolF. Using AIBECS, this is done via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"T_matrices = (T_age,)           # bundles all the transport matrices in a tuple\nsources_minus_sinks = (sms_age,) # bundles all the source-sink functions in a tuple\nF, ∇ₓF = state_function_and_Jacobian(T_matrices, sources_minus_sinks, nb) # generates the state function (and its Jacobian!)\nF(x₀,p₀)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"That's it! We have just created a model of the mean age.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Lines 2 and 3 are just telling AIBECS","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"what transport matrices it should use for the transport of these tracers, and\nand what local sources and sinks should be appplied to these tracers","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nThe (x,) syntax returns a tuple of one element — the comma is necessary because without it, (x) would be just like x with brackets around it. This interface of AIBECS was developed for case with multiple tracers in mind, and might look a bit odd for a single tracer. But in the future, this might be cleaned up to be easier to work with single tracers.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The fourth line creates two functions:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"F — the numerical version of the state function, boldsymbolF, of our model of the mean age, and\n∇ₓF — the Jacobian matrix of the state function, i.e., nabla_boldsymbolxboldsymbolF.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Yes, AIBECS just automatically created an exact derivative of your input, using autodifferentiation via dual numbers. (I'd be very excited to detail how this is implemented here, but it is an entirely different discussion.)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The last line just checks that our generated F works with our initial guess x₀ and parameter vector p₀.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Solving-for-the-steady-state-1","page":"Ideal mean age","title":"Solving for the steady-state","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The Jacobian, ∇ₓF is essential to solving the steady-state equation boldsymbolF(boldsymbolx boldsymbolp) = 0 fast. Specifically, solving boldsymbolF(boldsymbolx boldsymbolp) = 0 is done via Newton's method. By starting from an initial guess, that you will have to provide, it will iterate over this recursion relation","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"boldsymbolx_k+1 = boldsymbolx_k - nabla_boldsymbolxboldsymbolF(boldsymbolx_k boldsymbolp)^-1 boldsymbolF(boldsymbolx_k boldsymbolp)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"until boldsymbolF(boldsymbolx_k boldsymbolp) is sufficiently small. Now I should note that here, our age model is linear in x (or age in our code), so that the solution will be found in a single iteration, or a sinle \"matrix inversion\", as could be seen from our steady-state equation for boldsymbola.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nAIBECS comes with a built-in algorithm and an API to solve for the steady-state, so you don't have to worry about all these details!","category":"page"},{"location":"examples/generated/ideal_mean_age/#Define-the-Steady-state-problem-in-AIBECS-1","page":"Ideal mean age","title":"Define the Steady-state problem in AIBECS","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"First, we create an instance of the steady-state problem, via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"prob = SteadyStateProblem(F, ∇ₓF, x₀, p₀)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"where we have simply provided the state function, boldsymbolF, the Jacobian, nabla_boldsymbolxboldsymbolF, the initial guess and the parameters. The SteadyStateProblem function is a standard \"DiffEqBase\" constructor that I have overloaded in my package so that you can easily generate the model here.","category":"page"},{"location":"examples/generated/ideal_mean_age/#Solve-for-the-steady-state-with-AIBECS-1","page":"Ideal mean age","title":"Solve for the steady-state with AIBECS","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally, we can find the solution in litterally one line, via the solve function:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"age = solve(prob, CTKAlg())","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Here, I have provided the solve function with two things:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"the problem, prob, which we just defined, and\nthe quasi-Newton algorithm that I wrote in Julia, denoted by CTKAlg() after C.T. Kelley, who originally wrote it in MATLAB.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The last line should take about 10 seconds to 1 minute, depending on your laptop. That's it! We solved for the steady state! Everyone here deserves a nice tap on the shoulder — Good job! Now let's see what this age looks like on a map","category":"page"},{"location":"examples/generated/ideal_mean_age/#Figures-1","page":"Ideal mean age","title":"Figures","text":"","category":"section"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We will plot a horizontal slice of the age at about 1000m depth using Cartopy.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"First, we must rearrange age into the 3D model grid. For that we will need the vector of the indices of wet points in the 3D grid, which we will denote by iwet, and which AIBECS generates via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"iwet = indices_of_wet_boxes(grd)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We then rearrange the column vector age into a 3D array via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"age_3D = fill(NaN, size(grd)) # creates a 3D array of NaNs of the same size as the grid\nage_3D[iwet] = age              # Fills the wet grid boxes with the age values\nsize(age_3D)                    # Just to check the size of age_3D","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"The last line just shows you the size of age_3D, which is a 3D-array as expected.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Now let us find the index of the depth that is closest to 1000m. To do that we must use the depth information contained in grd. Let us first create a small vector of the depths of the grid:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"depth = grd.depth","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We could count the index of the entry we want, but here we will use the findfirst function to find the first depth index that is greater than 1000m.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"iz = findfirst(depth .> 1000u\"m\")\niz, depth[iz]","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We get iz = 13, which is a layer that lies at 1104m, close to 1000m like we wanted.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally, we need the latitude and longitudes of the grid, contained in grd. As for depth, we can use the OCIM's grd output:","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"lat, lon = ustrip.(grd.lat), ustrip.(grd.lon)","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"So these are the latitudes and longitudes of the map we are about to plot.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"A last thing we can do is convert the age from seconds, u\"s\", to years, u\"yr\", because the age is large. This can be done via the Unitful package (loaded automatically by AIBECS).","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"age_3D_1000m_yr = age_3D[:,:,iz] * ustrip(1.0u\"s\" |> u\"yr\")","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"Finally! Let's have a look at this ideal mean age! To make figures, here, we use Cartopy. To use it we simply type","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\"\nusing PyPlot, PyCall","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"note: Note\nThe first line is needed for Mac users. It's a bug that should eventually be resolved, but for now this seems to make it work.","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"We import cartopy, define a new plot, add some coastlines because they are pretty, and add our slice of age at 1000m depth to it via","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"clf()\nccrs = pyimport(\"cartopy.crs\")\nax = subplot(projection=ccrs.EqualEarth(central_longitude=-155.0))\nax.coastlines()\nlon_cyc = [lon; 360+lon[1]] # making it cyclic for Cartopy\nage_cyc = hcat(age_3D_1000m_yr, age_3D_1000m_yr[:,1])\np = contourf(lon_cyc, lat, age_cyc, levels=0:100:1200, transform=ccrs.PlateCarree(), zorder=-1)\ncolorbar(p, orientation=\"horizontal\")\ngcf() # gets the current figure to display","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"That's it! Good job!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"At 1000m, the age ranges from a few years below deep water formation regions (Wedell Sea, North Atlantic), and reaches a dozen of centuries in the North Pacific! This is pretty good for so little work!","category":"page"},{"location":"examples/generated/ideal_mean_age/#","page":"Ideal mean age","title":"Ideal mean age","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/P_model_2_tracers.jl\"","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Optimization-of-a-simple-phosphorus-cycling-model-1","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"tip: Tip\nThis example is also available as a Jupyter notebook: P_model_2_tracers.ipynb","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"warn: Warn\nThis example is not finished yet. It lacks a number of things, including explanatory text, references, and more. However, it can already serve as an example of model optimization.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Tracer-equations-1","page":"Optimization of a simple phosphorus cycling model","title":"Tracer equations","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We consider a simple model for the cycling of phosphorus with 2 state variables consisting of phosphate (PO₄) AKA dissolved inorganic phosphorus (DIP) and particulate organic phosphorus (POP). The dissolved phases are transported by advection and diffusion whereas the particulate phase sinks rapidly down the water column without any appreciable transport by the circulation.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"The governing equations that couple the 3D concentration fields of DIP and POP, denoted x_mathsfDIP and x_mathsfPOP, respectively, are:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"leftfracpartialpartial t + nabla cdot (boldsymbolu + mathbfKcdotnabla )right x_mathsfDIP = -U(x_mathsfDIP) + R(x_mathsfPOP)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"and","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"leftfracpartialpartial t + nabla cdot boldsymbolwright x_mathsfPOP = U(x_mathsfDIP) - R(x_mathsfPOP)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"The 3D vector boldsymbolu is the fluid velocity and mathbfK is the eddy-diffusion tensor. Thus, nabla cdot left boldsymbolu - mathbfK cdot nabla right is a differential operator that represents the transport by the ocean circulation. The 3D vector boldsymbolw is the particulate sinking velocity, so that the operator nabla cdot boldsymbolw acting on x_mathsfPOP is the divergence of the flux of POP. We will assume that it increases linearly with depth, i.e., that","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"boldsymbolw(boldsymbolr) = boldsymbolw_0 + boldsymbolw z","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"where boldsymbolw_0 and boldsymbolw are simple scalars, independent of location boldsymbolr. (z represents the depth of location boldsymbolr=(xyz).)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"The function U represents the biological uptake of DIP by phytoplankton, which we model as","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"U(x_mathsfDIP) = fracx_mathsfDIPtau  fracx_mathsfDIPx_mathsfDIP + k  (z  z_0)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"where the timescale, tau, sets the maximum specific DIP uptake rate. The first term in the product scales linearly with DIP, which is a nice property to have in general. It also makes it easier to reason about the extreme cases. However, here the uptake is not linear: the second term in the product is a hyperbolic term (after Monod or Michaelis-Menten) and reduces the slope of the uptake function when DIP is low. When DIP is very low, the slope is close to 0. But when DIP is very high, the slope is close to 1τ. The last term is to be understood as a condition, i.e., that the uptake happens only in the euphotic layer, where there is sufficient light for photosynthesis to occur. The depth z_0 is the depth of the euphotic layer.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"The function R defines the remineralization rate of POP, which converts POP back into DIP. For the remineralization, we simply use a linear rate constant, i.e.,","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"R(x_mathsfPOP) = kappa  x_mathsfPOP","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Translation-into-AIBECS-code-1","page":"Optimization of a simple phosphorus cycling model","title":"Translation into AIBECS code","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#Transport-matrices-1","page":"Optimization of a simple phosphorus cycling model","title":"Transport matrices","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We start by telling Julia we want to use the AIBECS","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"using AIBECS","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We load the circulation and grid of the OCIM0.1 via","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"grd, T_OCIM = OCIM0.load() ;","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"where the operator nabla cdot left boldsymbolu - mathbfK cdot nabla right is represented by the sparse matrix T_OCIM. In AIBECS, all the transport matrices must be declared as functions of the parameters p, so we simply define","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"T_DIP(p) = T_OCIM","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For the sinking of particles, we are going to create a sparse matrix that depends on the parameters, too, which define how fast particles sink.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"T_POP(p) = buildPFD(grd, settling_velocity = w(p))","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"for which we need to define the sinking speed w(p) as a function of the parameters p. Following the assumption that it increases linearly with depth, we write it as","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"w(p) = p.w₀ .+ p.w′ * z","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For this to work, we must create a vector of depths, z, which is simply done via","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"iwet = findall(vec(grd.wet3D))\nz = ustrip.(grd.depth_3D[iwet])","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"(We must strip the units via ustrip because units do not percolate through the functionality of AIBECS flawlessly at this early stage of development.) We combine the transport operators for DIP and POP into a single tuple via","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"T_all = (T_DIP, T_POP) ;","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Local-sources-and-sinks-1","page":"Optimization of a simple phosphorus cycling model","title":"Local sources and sinks","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#Geological-Restoring-1","page":"Optimization of a simple phosphorus cycling model","title":"Geological Restoring","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Because AIBECS will solve for the steady state solution directly without time-stepping the goverining equations to equilibrium, we don't have any opportunity to specify any intial conditions. Initial conditions are how the total amount of conserved elements get specified in most global biogeochemical modelels. Thus to specify the total inventory of P in AIBECS we add a very weak resporing term to, e.g., the DIP equation. The time-scale for this restoring term is chosen to be very long compared to the timescale with which the ocean circulation homogenizes a tracer. Because of this long timescale we call it the geological restoring term, but geochemists who work on geological processes don't like that name! In any event the long timescale allows us to prescribe the total inventory of P in a way that yields the same solution we would have gotten had we time-stepped the model to steady-state with the total inventory prescribed by the initial condition. We define the geological restoring simply as","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"geores(x, p) = (p.DIPgeo .- x) / p.τgeo","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Uptake-(DIP-POP)-1","page":"Optimization of a simple phosphorus cycling model","title":"Uptake (DIP → POP)","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For the phosphate uptake, we must take some precautions to avoid the pole of the hyperbolic term. That is, we ensure that uptake only occurs when DIP is positive via the relu function","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"relu(x) = (x .≥ 0) .* x","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Then we simply write the uptake as a Julia function, following the definition of U:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"function uptake(DIP, p)\n    τ, k, z₀ = p.τ, p.k, p.z₀\n    DIP⁺ = relu(DIP)\n    return 1/τ * DIP⁺.^2 ./ (DIP⁺ .+ k) .* (z .≤ z₀)\nend","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"where we have \"unpacked\" the parameters to make the code clearer and as close to the mathematical equation as possible.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Remineralization-(POP-DIP)-1","page":"Optimization of a simple phosphorus cycling model","title":"Remineralization (POP → DIP)","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"remineralization(POP, p) = p.κ * POP","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Net-sources-and-sinks-1","page":"Optimization of a simple phosphorus cycling model","title":"Net sources and sinks","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We lump the sources and sinks into sms functions (for Sources Minus Sinks):","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"function sms_DIP(DIP, POP, p)\n    return -uptake(DIP, p) + remineralization(POP, p) + geores(DIP, p)\nend\nfunction sms_POP(DIP, POP, p)\n    return  uptake(DIP, p) - remineralization(POP, p)\nend","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"and create a tuple of those just like for the transport matrices via","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"sms_all = (sms_DIP, sms_POP) # bundles all the source-sink functions in a tuple","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For the sake of this notebook, however, we write more efficient BGC functions for the sources and sinks by using \"in place\" functions that mutate a preallocated vector to avoid allocations. G_DIP! replaces sms_DIP:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"function G_DIP!(dDIP, DIP, POP, p)\n    τ, k, z₀, κ, DIPgeo, τgeo = p.τ, p.k, p.z₀, p.κ, p.DIPgeo, p.τgeo\n    dDIP .= @. -(DIP ≥ 0) / τ * DIP^2 / (DIP + k) * (z ≤ z₀) + κ * POP + (DIPgeo - DIP) / τgeo\n    return dDIP\nend","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Note the use of the @. macro to \"fuse\" the loops together, which is faster than looping for each operation. And G_POP! replaces sms_POP:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"function G_POP!(dPOP, DIP, POP, p)\n    τ, k, z₀, κ = p.τ, p.k, p.z₀, p.κ\n    dPOP .= @. (DIP ≥ 0) / τ * DIP^2 / (DIP + k) * (z ≤ z₀) - κ * POP\n    return dPOP\nend","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"which we bundle into","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Gs = (G_DIP!, G_POP!)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Parameters-1","page":"Optimization of a simple phosphorus cycling model","title":"Parameters","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We now define and build the parameters. In AIBECS, this is done by first creating a table of parameters, using the API designed for it. First, we create an empty table:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"t = empty_parameter_table()    # empty table of parameters","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Then, we add every parameter that we need","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"add_parameter!(t, :DIPgeo, 2.12u\"mmol/m^3\",\n               optimizable = true,\n               variance_obs = ustrip(upreferred(0.1 * 2.17u\"mmol/m^3\"))^2,\n               description = \"Mean PO₄ concentration\")\nadd_parameter!(t, :τgeo, 1.0u\"Myr\",\n               description = \"Geological restoring timescale\")\nadd_parameter!(t, :k, 6.62u\"μmol/m^3\",\n               optimizable = true,\n               description = \"Half-saturation constant (Michaelis-Menten)\")\nadd_parameter!(t, :z₀, 80.0u\"m\",\n               description = \"Depth of the euphotic layer base\")\nadd_parameter!(t, :w₀, 0.64u\"m/d\",\n               optimizable = true,\n               description = \"Sinking velocity at surface\")\nadd_parameter!(t, :w′, 0.13u\"1/d\",\n               optimizable = true,\n               description = \"Vertical gradient of sinking velocity\")\nadd_parameter!(t, :κ, 0.19u\"1/d\",\n               optimizable = true,\n               description = \"Remineralization rate constant (POP to DIP)\")\nadd_parameter!(t, :τ, 236.52u\"d\",\n               optimizable = true,\n               description = \"Maximum uptake rate timescale\")","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"These values of these parameters have been optimized for the same model but embedded in the OCIM1 circulation and should yield a pretty good fit to observations. However, because the circulation has changed from the OCIM1 to the OCIM0.1 used here, the best parameters have probably changed, too. Thus, we will re-optimize these parameters below. But first, we will just try to find the steady-state solution with these initial parameter values.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We generate a new type for the parameters, via","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"initialize_Parameters_type(t, \"Pcycle_Parameters\")   # Generate the parameter type","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Finally, we can instantiate the parameter vector in a single line:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"p = Pcycle_Parameters()","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"where we have used the name of the new type that we created just earlier.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Finding-the-steady-state-solution-1","page":"Optimization of a simple phosphorus cycling model","title":"Finding the steady-state solution","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#Generate-state-function-and-Jacobian-1","page":"Optimization of a simple phosphorus cycling model","title":"Generate state function and Jacobian","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We generate the in-place state function F! and its Jacobian in a single line and the out-of-place F for use by the solver. (Using dx = similar(x) creates a vector of the same type and size as x but without spending time copying its values, which is OK because we always fill the entire dx in calls to g_DIP! and G_POP!`.)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"nb = length(iwet)\nF!, ∇ₓF = inplace_state_function_and_Jacobian(T_all, Gs, nb)\nF(x::Vector{Tx}, p::Pcycle_Parameters{Tp}) where {Tx,Tp} = F!(Vector{promote_type(Tx,Tp)}(undef,length(x)),x,p)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Solve-for-the-steady-state-1","page":"Optimization of a simple phosphorus cycling model","title":"Solve for the steady-state","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We start from an initial guess,","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"x = p.DIPgeo * ones(2nb) # initial iterate","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Create an instance of the steady-state problem","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"and solve it","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"s = solve(prob, CTKAlg()).u","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Plotting-1","page":"Optimization of a simple phosphorus cycling model","title":"Plotting","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For plotting, we first unpack the state","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"DIP, POP = state_to_tracers(s, nb, 2)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We will plot the concentration of DIP at a given depth horizon","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"iz = findfirst(grd.depth .> 2000u\"m\")\niz, grd.depth[iz]","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"DIP_3D = rearrange_into_3Darray(DIP, grd)\nDIP_2D = DIP_3D[:,:,iz] * ustrip(1.0u\"mol/m^3\" |> u\"mmol/m^3\")\nlat, lon = ustrip.(grd.lat), ustrip.(grd.lon)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Create the Cartopy canvas, make the data cyclic in order for the plot to look good in Cartopy, and plot the filled contour via contourf","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\"\nusing PyPlot, PyCall\nclf()\nccrs = pyimport(\"cartopy.crs\")\ncfeature = pyimport(\"cartopy.feature\")\nax = subplot(projection = ccrs.EqualEarth(central_longitude=-155.0))\nax.add_feature(cfeature.COASTLINE, edgecolor=\"#000000\") # black coast lines\nax.add_feature(cfeature.LAND, facecolor=\"#CCCCCC\")      # gray land\nlon_cyc = [lon; 360+lon[1]]\nDIP_2D_cyc = hcat(DIP_2D, DIP_2D[:,1])\nplt = contourf(lon_cyc, lat, DIP_2D_cyc, levels=0:0.2:3.6, transform=ccrs.PlateCarree(), zorder=-1)\ncolorbar(plt, orientation=\"horizontal\");\ntitle(\"PO₄ at $(string(round(typeof(1u\"m\"),grd.depth[iz]))) depth using the OCIM0.1 circulation\")\ngcf()","category":"page"},{"location":"examples/generated/P_model_2_tracers/#Optimizing-the-model-parameters-1","page":"Optimization of a simple phosphorus cycling model","title":"Optimizing the model parameters","text":"","category":"section"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"To optimize the model, we will use data from the World Ocean Atlas (WOA). Specifically, we will use the observed PO<sub>4</sub> climatology, which the WOA produces every few years. Thanks to the WorldOceanAtlasTools package combined with some AIBECS functionality, this is done a just a few commands:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"using WorldOceanAtlasTools\nμDIPobs3D, σ²DIPobs3D = WorldOceanAtlasTools.fit_to_grid(grd, 2018, \"phosphate\", \"annual\", \"1°\", \"an\")\nμDIPobs, σ²DIPobs = μDIPobs3D[iwet], σ²DIPobs3D[iwet]\nμx = (μDIPobs, missing)\nσ²x = (σ²DIPobs, missing)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We define some hyper parameters for the weight of the mismatch of DIP, POP, and the parameters with observations / their prior estimates.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"ωs = [1.0, 0.0] # the weight for the mismatch (weight of POP = 0)\nωp = 1e-4       # the weight for the parameters prior estimates","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We then generate the objective function and some derivatives using the PO₄ mean and variance","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"v = ustrip.(vector_of_volumes(grd))\nf   =   generate_objective(ωs, μx, σ²x, v, ωp, mean_obs(p), variance_obs(p))\n∇ₓf = generate_∇ₓobjective(ωs, μx, σ²x, v, ωp, mean_obs(p), variance_obs(p))\n∇ₚf = generate_∇ₚobjective(ωs, μx, σ²x, v, ωp, mean_obs(p), variance_obs(p))","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For the optimization, we will use the F-1 algorithm from the F1Method package.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"using F1Method","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"For the F-1 algorithm, we must initialize the memory buffer","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"mem = F1Method.initialize_mem(s, p)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We then define the objective, gradient, and Hessian using the F1Method package API","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"objective(p) = F1Method.objective(f, F, ∇ₓF, mem, p, CTKAlg())\ngradient(p) = F1Method.gradient(f, F, ∇ₓf, ∇ₓF, mem, p, CTKAlg())\nhessian(p) = F1Method.hessian(f, F, ∇ₓf, ∇ₓF, mem, p, CTKAlg())","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Because we want the parameters to remain positive, we define the change of variables The change variable from vector λ = log(p) to Parameters p:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"λ2p(λ) = AIBECS.opt_para(exp.(λ))","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"and the corresponding derivatives:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"∇λ2p(λ) = exp.(λ)\n∇²λ2p(λ) = exp.(λ)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Reverse change of variables from Parameters p to vector λ","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"p2λ(p) = log.(optvec(p))\nλ = p2λ(p)\n\nobj(λ) = objective(λ2p(λ))\nusing LinearAlgebra\ngrad(λ) = gradient(λ2p(λ)) * Diagonal(∇λ2p(λ))\nfunction hess(λ)\n    ∇p = Diagonal(∇λ2p(λ)) # for variable change\n    ∇²p = Diagonal(∇²λ2p(λ)) # for variable change\n    G = vec(gradient(λ2p(λ)))\n    H = hessian(λ2p(λ))\n    return ∇p * H * ∇p + Diagonal(G) * ∇²p\nend","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Use optim to optimize","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"using Optim","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Add storage for use with Optim","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"m = length(p)\ngrad(s, λ) = s[1:m] .= vec(grad(λ))\nhess(s, λ) = s[1:m,1:m] .= hess(λ)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Set options of Optim","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"opt = Optim.Options(store_trace = false, show_trace = true, extended_trace = false)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"The starting parameters are","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"p","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Run optimization","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"results = optimize(obj, grad, hess, λ, NewtonTrustRegion(), opt)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Because we started from an other optimized set of parameters, this should only take a few iterations. The optimized parameters are","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"p_optimized = λ2p(results.minimizer)","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"After optimizing these parameters, we expect the fit to be better. Let's have a look at the optimized steady-state solution at the same depth as earlier, and compare it to the observed DIP field. First, let's calculate the steady-state with the optimized parameters.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"prob_optimized = SteadyStateProblem(F, ∇ₓF, s, p_optimized)\ns_optimized = solve(prob_optimized, CTKAlg()).u","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"Like earlier, we fill in a 3D array of NaNs with the values we want to plot. Here, we fill the arrays with the fractional difference bewteen modeled and observed DIP:","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"DIPold, _ = state_to_tracers(s, nb, 2)\nDIPnew, _ = state_to_tracers(s_optimized, nb, 2)\nδDIPold_3D = fill(NaN, size(grd))\nδDIPold_3D[iwet] .= 100(DIPold - μDIPobs) ./ μDIPobs\nδDIPnew_3D = fill(NaN, size(grd))\nδDIPnew_3D[iwet] .= 100(DIPnew - μDIPobs) ./ μDIPobs","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"And take a slice at depth index iz","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"δDIPold_2D = δDIPold_3D[:,:,iz]\nδDIPnew_2D = δDIPnew_3D[:,:,iz]","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We make those 2D slices cyclic along the longitude for Cartopy","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"δDIPold_cyc = hcat(δDIPold_2D, δDIPold_2D[:,1])\nδDIPnew_cyc = hcat(δDIPnew_2D, δDIPnew_2D[:,1])","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"And we plot the mismatch of the old, OCIM1-optimized field","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"figure()\nδDIPlevels = -20:2:20\nax = subplot(projection = ccrs.EqualEarth(central_longitude=-155.0))\nax.add_feature(cfeature.COASTLINE, edgecolor=\"#000000\") # black coast lines\nax.add_feature(cfeature.LAND, facecolor=\"#CCCCCC\")      # gray land\nplt2 = contourf(lon_cyc, lat, δDIPold_cyc, cmap=\"PiYG_r\", levels=δDIPlevels, transform=ccrs.PlateCarree(), zorder=-1, extend=\"both\")\ncbar2 = colorbar(plt2, orientation=\"horizontal\", extend=\"both\")\ncbar2.set_label(\"δDIP / DIP [%]\")\ntitle(\"old DIP mismatch at $(string(round(typeof(1u\"m\"),grd.depth[iz]))) depth using the OCIM0.1 circulation\")\ngcf()","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"We can see a significant negative bias in the North Atlantic. This is probably due to having swapped the circulation from OCIM1 to OCIM0.1. Let's plot the OCIM-0.1-optimized mismatch","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"figure()\nax = subplot(projection = ccrs.EqualEarth(central_longitude=-155.0))\nax.add_feature(cfeature.COASTLINE, edgecolor=\"#000000\") # black coast lines\nax.add_feature(cfeature.LAND, facecolor=\"#CCCCCC\")      # gray land\nplt3 = contourf(lon_cyc, lat, δDIPnew_cyc, cmap=\"PiYG_r\", levels=δDIPlevels, transform=ccrs.PlateCarree(), zorder=-1, extend=\"both\")\ncbar3 = colorbar(plt3, orientation=\"horizontal\", extend=\"both\")\ncbar3.set_label(\"δDIP / DIP [%]\")\ntitle(\"new DIP mismatch at $(string(round(typeof(1u\"m\"),grd.depth[iz]))) depth using the OCIM0.1 circulation\")\ngcf()","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"This shows that most of the negative bias has been corrected. (The green patch in the North Atlantic has dissipated.) Of course, this optimization was \"easy\", because there were only 2 tracers, few parameters, and we started from a pretty good solution. However, this type of optimization can really improve the skill of models, even current \"state-of-the-art\" ones. Such optimizations turn average models into better tools for cutting-edge oceanography research.","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"note: Note\nIf you find any bugs or ideas you want to test and struggle with the AIBECS, don't hesitate to raise issues on the GitHub AIBECS repository or contact me!","category":"page"},{"location":"examples/generated/P_model_2_tracers/#","page":"Optimization of a simple phosphorus cycling model","title":"Optimization of a simple phosphorus cycling model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/radiocarbon_OCIM.jl\"","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Radiocarbon-with-OCIM1-1","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"tip: Tip\nThis example is also available as a Jupyter notebook: radiocarbon_OCIM.ipynb","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Setup-the-Radiocarbon-model-1","page":"Radiocarbon with OCIM1","title":"Setup the Radiocarbon model","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We will use the same model of the radiocarbon that is in the trcaer-transport-operator example.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"Radiocarbon, ¹⁴C, is produced by cosmic rays in the lower stratosphere and upper troposphere. It quickly reacts with oxygen to produce ¹⁴CO₂, which is then mixed throughout the troposphere and enters the ocean through air–sea gas exchange. Because the halflife of radiocarbon is only 5730 years a significant amount of decay can occur before the dissolved inorganic radiocarbon (DI¹⁴C) can mix uniformally throughout the ocean. As such the ¹⁴C serves as a tracer label for water that was recently in contact with the atmosphere.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Tracer-Equation-1","page":"Radiocarbon with OCIM1","title":"Tracer Equation","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"Mathematically, the ¹⁴C tracer concentration, denoted R (for Radiocarbon), satisfies the following tracer equation:","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"fracpartial Rpartial t + nabla cdot left boldsymbolu - mathbfK cdot nabla right R = Lambda(R_mathsfatm - R) - R  tau","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"where Lambda(R_mathsfatm - R) represents the air–sea exchanges and R  tau the radioactive decay rate. (tau is the radioactive decay timescale.)","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"The discretized tracer is thus given by","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"fracpartial boldsymbolRpartial t + mathbfT  boldsymbolR = mathbfLambda(R_mathsfatm - boldsymbolR) - boldsymbolR  tau","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Translation-to-AIBECS-Code-1","page":"Radiocarbon with OCIM1","title":"Translation to AIBECS Code","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We will perform an idealized radiocarbon simulation in our model and use the ocean circulation defined earlier using AIBECS. In this model we prescribe the atmospheric concentration, R_mathsfatm, to be simply equal to 1. (We do not specify its unit or its specific value because it is not important for determining the age of a water parcel — only the decay rate does.)","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"To use AIBECS, one must put the equations into the generic form of","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"fracpartial boldsymbolxpartial t + mathbfT(boldsymbolp)  boldsymbolx = boldsymbolG(boldsymbolx boldsymbolp)","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"where boldsymbolx is the state vector, boldsymbolp is the vector of model parameters, mathbfT(boldsymbolp) is the transport operator, and boldsymbolG(boldsymbolx boldsymbolp) is the local sources minus sinks.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"In our radiocarbon-model context, with boldsymbolx = boldsymbolR, we have that","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"boldsymbolG(boldsymbolx boldsymbolp) = mathbfLambda(R_mathsfatm - boldsymbolx) - boldsymbolx  tau","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"Hence, we must create T(p) and G(x,p) to give AIBECS the means to simulate the tracer distribution and/or its evolution in time.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"Like for any models using AIBECS, we start by telling Julia just that:","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"using AIBECS","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We then load the OCIM1 model (the grid and the transport) via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"grd, T = OCIM1.load() ;","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Sources-and-Sinks-1","page":"Radiocarbon with OCIM1","title":"Sources and Sinks","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"The local sources and sinks are thus simply given by","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"function G(x, p)\n    τ, Ratm = p.τ, p.Ratm\n    return Λ(Ratm .- x, p) - x / τ\nend","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"where τ is the decay rate timescale and Ratm is the atmospheric concentration of radiocarbon.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We must define the air–sea exchange rate, Λ(x,p), which requires us to define which boxes are located at the surface first. This is done, e.g., via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"iwet = indices_of_wet_boxes(grd)\nsurface_boxes = grd.depth_3D[iwet] .== grd.depth[1]","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"The air–sea exchange rate is then given by","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"function Λ(x, p)\n    λ, h = p.λ, p.h\n    return λ / h * surface_boxes .* x\nend","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"where λ is the piston velocity and h is the height of the top layer of the model grid.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Parameters-1","page":"Radiocarbon with OCIM1","title":"Parameters","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"For the air–sea gas exchange, we use a constant piston velocity lambda of 50m / 10years, which will happen in the top layer, of height given by, well, the height of the top layer. And for the radioactive decay we use a timescale tau of 5730/log(2) years. We define these as parameters using the dedicated API from the AIBECS:","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"t = empty_parameter_table()                   # initialize an empty table of parameters\nadd_parameter!(t, :τ, 5730u\"yr\"/log(2)) # radioactive decay e-folding timescale\nadd_parameter!(t, :λ, 50u\"m\" / 10u\"yr\") # piston velocity\nadd_parameter!(t, :h, grd.δdepth[1])    # height of top layer\nadd_parameter!(t, :Ratm, 1.0u\"mol/m^3\") # atmospheric concentration\nt","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"shows the parameters that you just created.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We now generate a new object to contain all these parameters via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"initialize_Parameters_type(t, \"C14_OCIM_parameters\") # creates the type for parameters\np = C14_OCIM_parameters()                            # creates the parameters object","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Generate-the-state-function-and-its-Jacobian-1","page":"Radiocarbon with OCIM1","title":"Generate the state function and its Jacobian","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"The last step for the setup is for AIBECS to create boldsymbolF(boldsymbolx boldsymbolp) = boldsymbolG(boldsymbolx boldsymbolp) - mathbfT(boldsymbolp)  boldsymbolx, which defines the rate of change of the state, boldsymbolx. This is done via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"F, ∇ₓF = state_function_and_Jacobian(p -> T, G) # generates the state function (and its Jacobian!)\nnb = length(iwet)\nx = zeros(nb)\nF(x,p)","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"note: Note\nHere, AIBECS has automatically created ∇ₓF, i.e., nabla_boldsymbolxboldsymbolF(boldsymbolx boldsymbolp), which is the Jacobian of the system. This Jacobian will be useful in the simulations below.","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"That's it! Your model is entirely setup and ready to be used for simulations!","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Run-the-Radiocarbon-model-1","page":"Radiocarbon with OCIM1","title":"Run the Radiocarbon model","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#Compute-the-steady-state-1","page":"Radiocarbon with OCIM1","title":"Compute the steady-state","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"Because this model, embedded in the OCIM1 circulation, is much bigger than when embedded in the 5-box shoebox model, it would take quite some computational resournces (in time) to implicitly time-step. Instead, we will directly solve for the steady-state. For that, we simply define the steady-state problem and solve it via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p) # define the problem\nR = solve(prob, CTKAlg()).u             # solve the problem","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"This should take a few seconds on a laptop. Once the radiocarbon concentration is computed, we can convert it into the corresponding age, via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"C14age = -log.(R) * p.τ * u\"s\" .|> u\"yr\"","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#Plot-the-radiocarbon-age-1","page":"Radiocarbon with OCIM1","title":"Plot the radiocarbon age","text":"","category":"section"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"First, we must rearrange the age from its column vector shape into the corresponding 3D field. We start by filling a 3D array of the same size as the grid with some NaNs. (It serves as a blank canvas that we will \"color\" in with our computed age.)","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"C14age_3D = fill(NaN, size(grd))     # creates a 3D array of NaNs","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We use the indices of wet boxes, iwet, to fill in the 3D array, via","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"C14age_3D[iwet] .= ustrip.(C14age)   # Fills the wet grid boxes with the age values","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"where we have removed the unit (for plotting). We then pick a layer to plot, e.g., the first layer with a depth larger than 700m. For that, we create iz, which is the index of that layer:","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"iz = findfirst(grd.depth .> 700u\"m\") # aim for a depth of ~ 700 m","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"We then take a horizontal 2D slice of the 3D age at index iz","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"C14age_3D_1000m_yr = C14age_3D[:,:,iz]","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"Finally, we plot the radiocarbon age using Cartopy, via:","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\"\nusing PyPlot, PyCall\nclf()\nccrs = pyimport(\"cartopy.crs\")\nax = subplot(projection=ccrs.EqualEarth(central_longitude=-155.0))\nax.coastlines()\nlon_cyc = ustrip.([grd.lon; grd.lon[1] + 360u\"°\"]) # making it cyclic for Cartopy\nage_cyc = hcat(C14age_3D_1000m_yr, C14age_3D_1000m_yr[:,1])\np = contourf(lon_cyc, ustrip.(grd.lat), age_cyc, levels=0:100:2000, transform=ccrs.PlateCarree(), zorder=-1)\ncolorbar(p, orientation=\"horizontal\")\ntitle(\"¹⁴C age at $(string(round(typeof(1u\"m\"),grd.depth[iz]))) depth using the OCIM1 circulation\")\ngcf() # gets the current figure to display","category":"page"},{"location":"examples/generated/radiocarbon_OCIM/#","page":"Radiocarbon with OCIM1","title":"Radiocarbon with OCIM1","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<img src=\"https://user-images.githubusercontent.com/4486578/60554111-8fc27400-9d79-11e9-9ca7-6d78ee89ea70.png\" alt=\"logo\" title=\"AIBECS_logo\" align=\"middle\" width=\"50%\"/>","category":"page"},{"location":"#AIBECS.jl-1","page":"Home","title":"AIBECS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Algebraic Implicit Biogeochemistry Elemental Cycling System","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Work in Progress)","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"AIBECS may be pronounced like the cool ibex (if you have a french accent). AIBECS is a new software written in Julia to easily create some marine biogeochmistry models in just a few commands.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nAIBECS is developed primarily by Benoît Pasquier with the help of François Primeau and J. Keith Moore from the Department of Earth System Science at the University of California, Irvine, USA. This software is in active development, so if you have any suggestions or feature requests, do not hesitate to start an issue directly on the AIBECS GitHub repository!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AIBECS is not just a single model. It's a system that allows you to create a global steady-state biogeochmistry model with just a few simple commands. Basically, you just need to tell AIBECS","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which ocean circulation to use (from simple toy models of just a few boxes to more complicated global models of the circulation),\nwhat elements you want to model/track and \nhow each tracer gets converted into other tracers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Once the model is set up, you can run simulations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AIBECS relies on many tools from linear algebra to run simulations and perform optimizations really fast. AIBECS-generated models are described by a state function, denoted boldsymbolF, which defines how the concnetrations of elements in the ocean evolve with time. In mathematical terms, this translates to a system of nonlinear differential equations with the generic form ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"fracpartial boldsymbolxpartial t = boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where boldsymbolx is the state of the model (i.e., the concentrations of the tracers), and boldsymbolp are model parameters. Here, we are interested in the equilibrium of the system (AKA the steady-state). That is when the time-derivative is 0, so that","category":"page"},{"location":"#","page":"Home","title":"Home","text":"boldsymbolF(boldsymbolx boldsymbolp) = 0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and boldsymbolx does not change with time. Instead of simulating the evolution of boldsymbolx with time and waiting for the system to reach equilibrium — like most biogeochemistry models do — AIBECS uses linear algebra techniques, like Newton's method in multiple dimensions, or Krylov spaces, to implicitly solve for the steady-state solution, hence the \"algebraic\" and \"implicit\" names. This makes AIBECS much faster than the competition!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you want to try AIBECS, head over to the prerequisites page to install the packages (this should take you a few minutes), and then open up one of the notebooks!","category":"page"},{"location":"prerequisites/#Prerequisites-1","page":"Prerequisites","title":"Prerequisites","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This section provides a set of instructions and prerequisites to use AIBECS.","category":"page"},{"location":"prerequisites/#.-Install-Julia-1","page":"Prerequisites","title":"1. Install Julia","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"First things first, you must install Julia. Click on the Julia link, look for the \"download\" buttons, and install the correct version for your OS. Once this is done, you should be able to start Julia by typing","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"in the terminal. If not, find the Julia executable, and simply double click on it! This should open a terminal session, and display something like this:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.1.1 (2019-05-16)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This is called the Julia REPL (for Read Eval Loop Print) and is used for interactive use of Julia. Great job, Julia is now running on your computer! Congratulations!","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"If you want to learn more about Julia, you can read the documentation, there is a Discourse forum, and there is a Slack channel if you need help. But for now you should not need any of those: The notebook will just require you to press Shift + Enter a couple of times.","category":"page"},{"location":"prerequisites/#.-Julia-packages-required-for-the-notebooks-1","page":"Prerequisites","title":"2. Julia packages required for the notebooks","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In Julia, you can access the package manager by simply typing ] in the REPL. Once you type ], the REPL changes to","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg>","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This means you're in the package-manager (or pkg) mode.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Note that you can exit the pkg mode by pressing the delete key, and this will revert the Julia prompt to its original form:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia>","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"The packages you should install are:","category":"page"},{"location":"prerequisites/#[AIBECS](https://github.com/briochemc/AIBECS.jl)-1","page":"Prerequisites","title":"AIBECS","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"To create a global steady-state biogeochemistry model, we will be using the AIBECS package. You install it, via","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"add AIBECS","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"in pkg mode, which should look like","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add AIBECS","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This should only take a few seconds.","category":"page"},{"location":"prerequisites/#[Cartopy](https://scitools.org.uk/cartopy/docs/latest/)-1","page":"Prerequisites","title":"Cartopy","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In order to plot things, i.e., to look at the output of the beautiful work you will be doing with AIBECS, you will need a plotting package. For good-looking maps, I suggest using Python's Cartopy because, well, it looks pretty. A few steps are necessary to install it:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Install the Conda package.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In pkg mode, do","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add Conda","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Install Cartopy using Conda (within Julia).","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"In REPL mode (i.e., not in pkg mode — press delete to get there from pkg mode), do","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia> using Conda; Conda.add(\"Cartopy\")","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Install PyPlot via","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add PyPlot","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Intall PyCall via","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add PyCall","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This should only take a few seconds as well.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nYou may want to install Cartopy differently, or even use a different plotting package. This is merely a suggestion that has worked well for me.","category":"page"},{"location":"prerequisites/#[IJulia](https://github.com/JuliaLang/IJulia.jl)-1","page":"Prerequisites","title":"IJulia","text":"","category":"section"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"For running the notebooks, I suggest using the IJulia package. Specifically, IJulia allows you to launch JupyterLab from Julia. To install it, in pkg mode, type add IJulia (and press return), and you should see something like:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"(v1.1) pkg> add IJulia","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"This should only take a few seconds as well.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nIJulia is recommended but not mandatory to run the notebooks. You could install JupyterLab outside of Julia and use that instead.","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nYou may need to build CodecZlib to run the notebooks. If you see an error mentioning you should build it, then build it! It's easy, just go in pkg mode and type build CodecZlib. It should look like this:(v1.1) pkg> build CodecZlib","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"If you followed all these steps you should be able to use the notebooks!","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"The final step is to start JupyterLab. First, make sure you are in the normal Julia REPL mode (i.e., press delete if you are in pkg mode.) Then, tell Julia that you want to \"use\" IJulia:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia> using IJulia","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nYou can just copy paste the code above (including the julia> bits), and the REPL will know to not paste those automatically. Everytime a package is used for the first time, Julia will precompile it (which can take a few seconds to minutes, depending on the package — don't worry, just let it finish).","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Finally, you can start JupyterLab from Julia by simply typing jupyerlab() in Julia. It should look like:","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"julia> jupyterlab()","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"note: Note\nIf Julia asks you if you want Conda to install JupyterLab, just say \"yes\" (i.e., type y). After a couple seconds/minutes of downloads and installations, you should be all set up and a browser window should open with JupyterLab!","category":"page"},{"location":"prerequisites/#","page":"Prerequisites","title":"Prerequisites","text":"Just navigate to the notebook of your choice with JupyterLab in your browser and double-click on the notebook!","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/p_cycle_DIP_DOP_POP.jl\"","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#A-Phosphorus-Cycling-Model-1","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"tip: Tip\nThis example is also available as a Jupyter notebook: p_cycle_DIP_DOP_POP.ipynb","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Tracer-equations-1","page":"A Phosphorus Cycling Model","title":"Tracer equations","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"We consider a simple model for the cycling of phosphorus with 3 state variables consisting of phosphate (PO₄) AKA dissolved inorganic phosphorus (DIP), dissolved organic phosphorus (DOP), and particulate organic phosphorus (POP).","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"The dissolved phases are transported by advection and diffusion whereas the particulate phase sinks rapidly down the water column without any appreciable transport by the circulation.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"The governing equations are:","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t DIP + nabla cdot leftboldsymbolu + mathbfKcdotnabla right DIP = -gamma(DIP) + kappa_mathsfD  DOP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t DOP + nabla cdot leftboldsymbolu + mathbfKcdot nabla right DOP = sigma  gamma(DIP) + kappa_mathsfP  POP - kappa_mathsfD  DOP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"and","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t POP + fracpartialpartial z leftw_mathsfP  POPright = (1-sigma)  gamma(DIP) - kappa_mathsfP  POP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"where boldsymbolu is the fluid velocity and mathbfK is the eddy-diffusion tensor. Thus, nabla cdot left boldsymbolu - mathbfK cdot nabla right is a differential operator that represents the transport by the ocean circulation. The function gamma(DIP) represents the biological uptake of DIP by phytoplankton.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Oxygen participates to this cycle too and satisfies its own tracer equation","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"fracpartialpartial t DO_2 + nabla cdot leftboldsymbolu + mathbfKcdotnabla right DO_2 = -r_mathsfO_2mathsfP  kappa_mathsfD  DOP + Lambda(DO_2 - O_2_mathsfsat)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"where Lambda is the air-sea gas exchange operator.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"These tracer equations depend on a number of scalars, that we list below","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Symbol Definition\nw_mathsfP depth dependent particle sinking speed\nsigma fraction of the organic matter production allocated to the dissolved phase\nkappa_mathsfD respiration rate for dissolved organic matter (DOP → DIP)\nkappa_mathsfP dissolution rate for particulate organic matter (POP → DOP)\nr_mathsfO_2mathsfP number of moles of O₂ needed to respire 1 mole of DOP","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"using AIBECS","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Load the circulation and grid","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"grd, T_Circulation = OCIM0.load() ;","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Define useful constants and arrays","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"iwet = indices_of_wet_boxes(grd)\nnb = length(iwet)\nz = ustrip.(vector_of_depths(grd))\nztop = vector_of_top_depths(grd) ;","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"And matrices","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"DIV = buildDIV(grd)\nIabove = buildIabove(grd) ;","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Transport-matrices-1","page":"A Phosphorus Cycling Model","title":"Transport matrices","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"T_DIP(p) = T_Circulation\nT_DOP(p) = T_Circulation\nT_DO2(p) = T_Circulation\nS₀ = buildPFD(ones(nb), DIV, Iabove)\nS′ = buildPFD(ztop, DIV, Iabove)\nfunction T_POP(p)\n    w₀, w′ = p.w₀, p.w′\n    return w₀ * S₀ + w′ * S′\nend\nT_all = (T_DIP, T_DOP, T_POP, T_DO2) ;","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Because AIBECS will solve for the steady state solution directly without time-stepping the goverining equations to equilibrium, we don't have any opportunity to specify any intial conditions. Initial conditions are how the total amount of conserved elements get specified in most global biogeochemical modelels. Thus to specify the total inventory of P in AIBECS we add a very weak resporing term to the DIP equation. The time-scale for this restoring term is chosen to be very long compared to the timescale with which the ocean circulation homogenizes a tracer. Because of this long timescale we call it the geological restoring term, but geochemists who work on geological processes don't like that name! In any event the long timescale allows us to prescribe the total inventory of P in a way that yields the same solution we would have gotten had we time-stepped the model to steady-state with the total inventory prescribed by the initial condition.","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Sources-minus-sinks-1","page":"A Phosphorus Cycling Model","title":"Sources minus sinks","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Geological-Restoring-1","page":"A Phosphorus Cycling Model","title":"Geological Restoring","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function geores(x, p)\n    τg, xgeo = p.τg, p.xgeo\n    return (xgeo .- x) / τg\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Uptake-of-phosphate-(DIP)-1","page":"A Phosphorus Cycling Model","title":"Uptake of phosphate (DIP)","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"relu(x) = (x .≥ 0) .* x\nfunction uptake(DIP, p)\n    τu, ku, z₀ = p.τu, p.ku, p.z₀\n    DIP⁺ = relu(DIP)\n    return 1/τu * DIP⁺.^2 ./ (DIP⁺ .+ ku) .* (z .≤ z₀)\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Remineralization-DOP-into-DIP-1","page":"A Phosphorus Cycling Model","title":"Remineralization DOP into DIP","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function respiration(DOP, p)\n    κDOP = p.κDOP\n    return κDOP * DOP\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Dissolution-of-POP-into-DOP-1","page":"A Phosphorus Cycling Model","title":"Dissolution of POP into DOP","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function dissolution(POP, p)\n    κPOP = p.κPOP\n    return κPOP * POP\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Air-sea-gas-exchange-1","page":"A Phosphorus Cycling Model","title":"Air-sea gas exchange","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"h = ustrip(grd.δdepth[1])             # thickness of the top layer\nz = grd.depth_3D[iwet]        # depth of the gridbox centers\nusing WorldOceanAtlasTools\nWOA = WorldOceanAtlasTools\nμDO2sat , σ²DO2sat = WOA.fit_to_grid(grd,2018,\"O2sat\",\"annual\",\"1°\",\"an\") ;\nDO2sat = vec(μDO2sat)[iwet]\nfunction airsea(DO2, p)\n    κDO2 = p.κDO2\n    return κDO2 * (z .< 20u\"m\") .* (DO2sat .- DO2) / h\nend","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Add them up into sms functions (Sources Minus Sinks)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"function sms_DIP(DIP, DOP, POP, DO2, p)\n    return -uptake(DIP, p) + respiration(DOP, p) + geores(DIP, p)\nend\nfunction sms_DOP(DIP, DOP, POP, DO2, p)\n    σ = p.σ\n    return σ * uptake(DIP, p) - respiration(DOP, p) + dissolution(POP, p)\nend\nfunction sms_POP(DIP, DOP, POP, DO2, p)\n    σ = p.σ\n    return (1 - σ) * uptake(DIP, p) - dissolution(POP, p)\nend\nfunction sms_DO2(DIP, DOP, POP, DO2, p)\n    rO2P = p.rO2P\n    return airsea(DO2,p) + rO2P * (uptake(DIP,p) - respiration(DOP,p))\nend\nsms_all = (sms_DIP, sms_DOP, sms_POP, sms_DO2,) # bundles all the source-sink functions in a tuple","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Parameters-1","page":"A Phosphorus Cycling Model","title":"Parameters","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"Build the parameters type and p₀","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"t = empty_parameter_table()    # initialize table of parameters\nadd_parameter!(t, :xgeo, 2.17u\"mmol/m^3\")\nadd_parameter!(t, :τg, 1.0u\"Myr\")\nadd_parameter!(t, :ku, 10.0u\"μmol/m^3\")\nadd_parameter!(t, :z₀, 80.0u\"m\")\nadd_parameter!(t, :w₀, 1.0u\"m/d\")\nadd_parameter!(t, :w′, 1/4.4625u\"d\")\nadd_parameter!(t, :κDOP, 1/0.25u\"yr\")\nadd_parameter!(t, :κPOP, 1/5.25u\"d\")\nadd_parameter!(t, :σ, 0.3u\"1\")\nadd_parameter!(t, :τu, 30.0u\"d\")\nadd_parameter!(t, :κDO2, 50u\"m\" / 30u\"d\")\nadd_parameter!(t, :rO2P, 175.0u\"mol/mol\")\ninitialize_Parameters_type(t, \"DIP_DOP_POP_O₂_Parameters\")   # Generate the parameter type","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#Generate-state-function-and-Jacobian-1","page":"A Phosphorus Cycling Model","title":"Generate state function and Jacobian","text":"","category":"section"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"nt = length(T_all)    # number of tracers\nn = nt * nb           # total dimension of the state vector\np = DIP_DOP_POP_O₂_Parameters() # parameters\nx = p.xgeo * ones(n) # initial iterate\nF, ∇ₓF = state_function_and_Jacobian(T_all, sms_all, nb)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"and solve","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"prob = SteadyStateProblem(F, ∇ₓF, x, p)\nnothing # s = solve(prob, CTKAlg()) # Not working yet","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"unpack state","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"DIP, DOP, POP, DO2 = state_to_tracers(x, nb, nt) # remove when line below works\nnothing # DIP, DOP, POP, DO2 = state_to_tracers(s.u, nb, nt)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"We will plot the concentration of DIP at a given depth horizon","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"depth = grd.depth\niz = findfirst(depth .> 200u\"m\")\niz, depth[iz]","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"DIP_3D = rearrange_into_3Darray(DIP, grd)\nDIP_2D = DIP_3D[:,:,iz] * ustrip(1.0u\"mol/m^3\" |> u\"mmol/m^3\")\nlat, lon = ustrip.(grd.lat), ustrip.(grd.lon)","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"and plot","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"ENV[\"MPLBACKEND\"]=\"qt5agg\"\nusing PyPlot, PyCall\nclf()\nccrs = pyimport(\"cartopy.crs\")\nax = subplot(projection = ccrs.EqualEarth(central_longitude=-155.0))\nax.coastlines()","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"making it cyclic for Cartopy","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"lon_cyc = [lon; 360+lon[1]]\nDIP_2D_cyc = hcat(DIP_2D, DIP_2D[:,1])","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"And plot","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"p = contourf(lon_cyc, lat, DIP_2D_cyc, levels=0:0.2:3.6, transform=ccrs.PlateCarree(), zorder=-1)\ncolorbar(p, orientation=\"horizontal\");\ngcf()","category":"page"},{"location":"examples/generated/p_cycle_DIP_DOP_POP/#","page":"A Phosphorus Cycling Model","title":"A Phosphorus Cycling Model","text":"This page was generated using Literate.jl.","category":"page"}]
}
