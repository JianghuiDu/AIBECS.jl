<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tracer Transport Operators ¬∑ AIBECS.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../../"><img class="logo" src="../../../assets/logo.png" alt="AIBECS.jl logo"/></a><h1>AIBECS.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><a class="toctext" href="../../../prerequisites/">Prerequisites</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../P_model_2_tracers/">Optimization of a simple phosphorus cycling model</a></li><li><a class="toctext" href="../ideal_mean_age/">Ideal mean age</a></li><li><a class="toctext" href="../p_cycle_DIP_DOP_POP/">A Phosphorus Cycling Model</a></li><li><a class="toctext" href="../radiocarbon_OCIM/">Radiocarbon with OCIM1</a></li><li class="current"><a class="toctext" href>Tracer Transport Operators</a><ul class="internal"><li><a class="toctext" href="#Discretization-1">Discretization</a></li><li><a class="toctext" href="#The-model-grid-and-the-transport-matrix-1">The model grid and the transport matrix</a></li><li><a class="toctext" href="#Radiocarbon-1">Radiocarbon</a></li><li><a class="toctext" href="#Time-stepping-1">Time stepping</a></li><li><a class="toctext" href="#Solving-Directly-for-the-Steady-State-1">Solving Directly for the Steady State</a></li></ul></li></ul></li><li><a class="toctext" href="../../../functions/">Function index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Tracer Transport Operators</a></li></ul><a class="edit-page" href="https://github.com/briochemc/AIBECS.jl/blob/master/docs/src/examples/tracer_transport_operators.jl"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tracer Transport Operators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tracer-Transport-Operators-1" href="#Tracer-Transport-Operators-1">Tracer Transport Operators</a></h1><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/briochemc/AIBECS.jl/blob/gh-pages/dev/examples/generated/tracer_transport_operators.ipynb"><code>tracer_transport_operators.ipynb</code></a></p></div></div><p>To model marine biogeochemical processes on a global scale we need to be able to account for the movement of chemical constituents both horizontally and vertically. We do this with a <strong>tracer transport operator</strong>. When this operator acts on a tracer field it produces the advective-diffusive divergence of the tracer.</p><h2><a class="nav-anchor" id="Discretization-1" href="#Discretization-1">Discretization</a></h2><p>In order to represent the transport operator on a computer one needs to discretize the tracer concentration field and the operator. Once discretized the tracer field is represented as a vector and the operator is represented as a sparse matrix.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A sparse matrix behaves the same way as a regular matrix. The only difference is that in a sparse matrix the majority of the entries are zeros. These zeros are not stored explicitly to save computer memory making it possible to deal with fairly high resolution ocean models.</p></div></div><p>Mathematically, the discretization converts an expression with partial derivatives into a matrix vector product. For the ocean circulation, we do the following conversion</p><div>\[\nabla \cdot \left[ \boldsymbol{u} - \mathbf{K} \cdot \nabla \right] C \longrightarrow \mathbf{T} \, \boldsymbol{C}\]</div><p>where <span>$C(\boldsymbol{r})$</span> is a tracer concentration at location <span>$\boldsymbol{r}$</span>. (We often omit the <span>$\boldsymbol{r}$</span> dependency in equations for brevity.) The <span>$\nabla \cdot \left[ \boldsymbol{u} - \mathbf{K} \cdot \nabla \right] C$</span> term is the flux divergence of the tracer due to the marine currents and turbulent eddies. (<span>$\boldsymbol{u}$</span> is the 3D current velocity and <span>$\mathbf{K}$</span> the diffusivity matrix.) The matrix <span>$\mathbf{T}$</span> is the flux divergence transport matrix and <span>$\boldsymbol{C}$</span> is the tracer concentration vector.</p><p>One can go a long way towards understanding what a tracer transport operator is by playing with a simple model with only a few boxes, which is the goal of this example.</p><p>The simple box model we consider is embeded in a 2√ó2√ó2 &quot;shoebox&quot;. It has 5 <em>wet</em> boxes and 3 <em>dry</em> boxes, as illustrated below:</p><img src="https://user-images.githubusercontent.com/4486578/58314610-3b130b80-7e53-11e9-9fe8-9527cdcca2d0.png" width =800><p>The circulation consists of</p><ul><li>a meridional overturning circulation flowing in a cycle through boxes 1 ‚Üí 2 ‚Üí 6 ‚Üí 5 ‚Üí 1 (shown in the &quot;meridional section 1&quot; panel above)</li><li>a zonal current in a reentrant cycling through boxes 1 ‚Üí 3 ‚Üí 1 (shown in the &quot;layer 1&quot; panel above)</li><li>vertical mixing representing deep convection between boxes 2 ‚Üî 6 (not shown)</li></ul><h2><a class="nav-anchor" id="The-model-grid-and-the-transport-matrix-1" href="#The-model-grid-and-the-transport-matrix-1">The model grid and the transport matrix</a></h2><p>Like for any models using AIBECS, we start by telling Julia just that:</p><pre><code class="language-julia">using AIBECS</code></pre><p>We then load the shoebox model via</p><pre><code class="language-julia">wet3D, grd, T = Primeau_2x2x2.load() ;</code></pre><pre><code class="language-none">(Bool[true true; true false]

Bool[true false; true false], , 
  [1, 1]  =  4.50923e-9
  [2, 1]  =  -5.88161e-10
  [3, 1]  =  -3.92107e-9
  [2, 2]  =  9.80268e-10
  [5, 2]  =  -5.60153e-11
  [1, 3]  =  -3.92107e-9
  [3, 3]  =  3.92107e-9
  [1, 4]  =  -5.88161e-10
  [4, 4]  =  3.36092e-11
  [2, 5]  =  -3.92107e-10
  [4, 5]  =  -3.36092e-11
  [5, 5]  =  5.60153e-11)</code></pre><p>where we have loaded 3 objects, <code>wet3D</code>, <code>grd</code>, and <code>T</code>.</p><p><code>wet3D</code> is 3D array representing the 3D ocean with <code>true</code> for &quot;wet&quot; boxes and <code>false</code> for &quot;dry&quot; boxes. Let&#39;s have a look at its contents:</p><pre><code class="language-julia">wet3D</code></pre><pre><code class="language-none">2√ó2√ó2 BitArray{3}:
[:, :, 1] =
 true   true
 true  false

[:, :, 2] =
 true  false
 true  false</code></pre><p>It&#39;s a 2√ó2√ó2 <code>BitArray</code>, i.e., an array of bit elements (the <code>true</code> and <code>false</code> entries). You can check that it matches our &quot;shoebox&quot; model. (Well, except for the orientation, for which northwards in the box model is downwards in the array.)</p><p>We can find all the wet boxes simply via</p><pre><code class="language-julia">findall(wet3D)</code></pre><pre><code class="language-none">5-element Array{CartesianIndex{3},1}:
 CartesianIndex(1, 1, 1)
 CartesianIndex(2, 1, 1)
 CartesianIndex(1, 2, 1)
 CartesianIndex(1, 1, 2)
 CartesianIndex(2, 1, 2)</code></pre><p>These are the 3D indices of the wet boxes, <code>(i,j,k)</code>, called the &quot;cartesian&quot; indices. If you want the &quot;linear&quot; indices, i.e., the numbers as shown in the image of the shoebox model, you can simply transform <code>wet3D</code> into a vector, via</p><pre><code class="language-julia">iwet = findall(vec(wet3D))</code></pre><pre><code class="language-none">5-element Array{Int64,1}:
 1
 2
 3
 5
 6</code></pre><p>We can also check that we indeed have the expected number of wet boxes via</p><pre><code class="language-julia">nb = length(iwet)</code></pre><pre><code class="language-none">5</code></pre><p>Now let&#39;s look at the grid, <code>grd</code>:</p><pre><code class="language-julia">grd</code></pre><pre><code class="language-none"></code></pre><p>It&#39;s an <code>OceanGrid</code> object, of size 2√ó2√ó2, as expected. This object is defined in the <a href="https://github.com/briochemc/OceanGrids.jl">OceanGrids</a> package, on which AIBECS depends. There are many ways to look inside the grid, one of which is to iterate over it:</p><pre><code class="language-julia">[println(box) for box in grd] ;</code></pre><pre><code class="language-none">8-element Array{Nothing,1}:
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing</code></pre><p>shows some details about all the boxes of the model, one at a time. The <code>grd</code> object also contains other information about the grid, like the 3D depths of the boxes:</p><pre><code class="language-julia">grd.depth_3D</code></pre><pre><code class="language-none">2√ó2√ó2 Array{Quantity{Float64,ùêã,Unitful.FreeUnits{(m,),ùêã,nothing}},3}:
[:, :, 1] =
 100.0 m  100.0 m
 100.0 m  100.0 m

[:, :, 2] =
 1950.0 m  1950.0 m
 1950.0 m  1950.0 m</code></pre><p>or the 3D latitudes:</p><pre><code class="language-julia">grd.lat_3D</code></pre><pre><code class="language-none">2√ó2√ó2 Array{Quantity{Float64,NoDims,Unitful.FreeUnits{(¬∞,),NoDims,nothing}},3}:
[:, :, 1] =
 -45.0¬∞  -45.0¬∞
  45.0¬∞   45.0¬∞

[:, :, 2] =
 -45.0¬∞  -45.0¬∞
  45.0¬∞   45.0¬∞</code></pre><p>where you can check that northwards = downwards in the array. You may notice these come with units! This helps ensure that degrees of latitude are not confused with meters for example.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia comes with <a href="https://github.com/PainterQubits/Unitful.jl">Unitful</a>, a package for using units, which AIBECS uses.</p></div></div><p>Finally, let&#39;s have a look at the transport matrix <code>T</code>, which represents <span>$\nabla \cdot \left[ \boldsymbol{u} - \mathbf{K} \cdot \nabla \right]$</span>, i.e., the flux divergence operator for dissolved tracers:</p><pre><code class="language-julia">T</code></pre><pre><code class="language-none">5√ó5 SparseMatrixCSC{Float64,Int64} with 12 stored entries:
  [1, 1]  =  4.50923e-9
  [2, 1]  =  -5.88161e-10
  [3, 1]  =  -3.92107e-9
  [2, 2]  =  9.80268e-10
  [5, 2]  =  -5.60153e-11
  [1, 3]  =  -3.92107e-9
  [3, 3]  =  3.92107e-9
  [1, 4]  =  -5.88161e-10
  [4, 4]  =  3.36092e-11
  [2, 5]  =  -3.92107e-10
  [4, 5]  =  -3.36092e-11
  [5, 5]  =  5.60153e-11</code></pre><p>It&#39;s a sparse matrix (a <code>SparseMatrixCSC</code> object in Julia), which only stores those entries that are not zero. We can display the full matrix via</p><pre><code class="language-julia">Matrix(T)</code></pre><pre><code class="language-none">5√ó5 Array{Float64,2}:
  4.50923e-9    0.0          -3.92107e-9  -5.88161e-10   0.0        
 -5.88161e-10   9.80268e-10   0.0          0.0          -3.92107e-10
 -3.92107e-9    0.0           3.92107e-9   0.0           0.0        
  0.0           0.0           0.0          3.36092e-11  -3.36092e-11
  0.0          -5.60153e-11   0.0          0.0           5.60153e-11</code></pre><p>to check its structure out. Note that all the diagonal terms are positive, which is the sign that the transport matrix acts as a divergence, which would be positive for a box containing all the tracer. For example, if there was only some tracer in box 2, then that tracer should &quot;diverge&quot; away from that box, resulting in the positiva value in that box:</p><pre><code class="language-julia">j = 2                            # index where we put some tracer
x = 1.0 * [i == j for i in 1:nb] # vector of 0&#39;s except for index j
x, (T * x)[j]</code></pre><pre><code class="language-none">([0.0, 1.0, 0.0, 0.0, 0.0], 9.802682357543846e-10)</code></pre><p>shows that the flux divergence <code>T * x</code> is positive where we injected the tracer.</p><h2><a class="nav-anchor" id="Radiocarbon-1" href="#Radiocarbon-1">Radiocarbon</a></h2><p>Radiocarbon, ¬π‚Å¥C, is produced by cosmic rays in the lower stratosphere and upper troposphere. It quickly reacts with oxygen to produce ¬π‚Å¥CO‚ÇÇ, which is then mixed throughout the troposphere and enters the ocean through air‚Äìsea gas exchange. Because the halflife of radiocarbon is only 5730 years a significant amount of decay can occur before the dissolved inorganic radiocarbon (DI¬π‚Å¥C) can mix uniformally throughout the ocean. As such the ¬π‚Å¥C serves as a tracer label for water that was recently in contact with the atmosphere.</p><h3><a class="nav-anchor" id="Tracer-Equation-1" href="#Tracer-Equation-1">Tracer Equation</a></h3><p>Mathematically, the ¬π‚Å¥C tracer concentration, denoted <span>$R$</span> (for Radiocarbon), satisfies the following tracer equation:</p><div>\[\frac{\partial R}{\partial t} + \nabla \cdot \left[ \boldsymbol{u} - \mathbf{K} \cdot \nabla \right] R = \Lambda(R_\mathsf{atm} - R) - R / \tau,\]</div><p>where <span>$\Lambda(R_\mathsf{atm} - R)$</span> represents the air‚Äìsea exchanges and <span>$R / \tau$</span> the radioactive decay rate. (<span>$\tau$</span> is the radioactive decay timescale.)</p><p>The discretized tracer is thus given by</p><div>\[\frac{\partial \boldsymbol{R}}{\partial t} + \mathbf{T} \, \boldsymbol{R} = \mathbf{\Lambda}(R_\mathsf{atm} - \boldsymbol{R}) - \boldsymbol{R} / \tau.\]</div><h3><a class="nav-anchor" id="Translation-to-AIBECS-Code-1" href="#Translation-to-AIBECS-Code-1">Translation to AIBECS Code</a></h3><p>We will perform an idealized radiocarbon simulation in our model and use the ocean circulation defined earlier using AIBECS. In this model we prescribe the atmospheric concentration, <span>$R_\mathsf{atm}$</span>, to be simply equal to 1. (We do not specify its unit or its specific value because it is not important for determining the age of a water parcel ‚Äî only the decay rate does.)</p><p>To use AIBECS, one must put the equations into the generic form of</p><div>\[\frac{\partial \boldsymbol{x}}{\partial t} + \mathbf{T}(\boldsymbol{p}) \, \boldsymbol{x} = \boldsymbol{G}(\boldsymbol{x}, \boldsymbol{p}),\]</div><p>where <span>$\boldsymbol{x}$</span> is the state vector, <span>$\boldsymbol{p}$</span> is the vector of model parameters, <span>$\mathbf{T}(\boldsymbol{p})$</span> is the transport operator, and <span>$\boldsymbol{G}(\boldsymbol{x}, \boldsymbol{p})$</span> is the local sources minus sinks.</p><p>In our radiocarbon-model context, with <span>$\boldsymbol{x} = \boldsymbol{R}$</span>, we have that</p><div>\[\boldsymbol{G}(\boldsymbol{x}, \boldsymbol{p}) = \mathbf{\Lambda}(R_\mathsf{atm} - \boldsymbol{x}) - \boldsymbol{x} / \tau.\]</div><p>Hence, we must create <code>T(p)</code> and <code>G(x,p)</code> to give AIBECS the means to simulate the tracer distribution and/or its evolution in time.</p><h4><a class="nav-anchor" id="Sources-and-Sinks-1" href="#Sources-and-Sinks-1">Sources and Sinks</a></h4><p>The local sources and sinks are thus simply given by</p><pre><code class="language-julia">function G(x, p)
    œÑ, Ratm = p.œÑ, p.Ratm
    return Œõ(Ratm .- x, p) - x / œÑ
end</code></pre><pre><code class="language-none">G (generic function with 1 method)</code></pre><p>where <code>œÑ</code> is the decay rate timescale and <code>Ratm</code> is the atmospheric concentration of radiocarbon.</p><p>We must define the air‚Äìsea exchange rate, <code>Œõ(x,p)</code>, which requires us to define which boxes are located at the surface first. This is done, e.g., via</p><pre><code class="language-julia">surface_boxes = grd.depth_3D[iwet] .== grd.depth[1]</code></pre><pre><code class="language-none">5-element BitArray{1}:
  true
  true
  true
 false
 false</code></pre><p>The air‚Äìsea exchange rate is then given by</p><pre><code class="language-julia">function Œõ(x, p)
    Œª, h = p.Œª, p.h
    return Œª / h * surface_boxes .* x
end</code></pre><pre><code class="language-none">Œõ (generic function with 1 method)</code></pre><p>where <code>Œª</code> is the piston velocity and <code>h</code> is the height of the top layer of the model grid.</p><h4><a class="nav-anchor" id="Parameters-1" href="#Parameters-1">Parameters</a></h4><p>For the air‚Äìsea gas exchange, we use a constant piston velocity <span>$\lambda$</span> of 50m / 10years, which will happen in the top layer, of height given by, well, the height of the top layer. And for the radioactive decay we use a timescale <span>$\tau$</span> of 5730/log(2) years. We define these as parameters using the dedicated API from the AIBECS:</p><pre><code class="language-julia">t = empty_parameter_table()                   # initialize an empty table of parameters
add_parameter!(t, :œÑ, 5730u&quot;yr&quot;/log(2)) # radioactive decay e-folding timescale
add_parameter!(t, :Œª, 50u&quot;m&quot; / 10u&quot;yr&quot;) # piston velocity
add_parameter!(t, :h, grd.Œ¥depth[1])    # height of top layer
add_parameter!(t, :Ratm, 1.0u&quot;mol/m^3&quot;) # atmospheric concentration
t</code></pre><table class="data-frame"><thead><tr><th></th><th>symbol</th><th>value</th><th>unit</th><th>printunit</th><th>mean_obs</th><th>variance_obs</th><th>optimizable</th><th>description</th><th>LaTeX</th></tr><tr><th></th><th>Symbol</th><th>Float64</th><th>Unitful‚Ä¶</th><th>Unitful‚Ä¶</th><th>Float64</th><th>Float64</th><th>Bool</th><th>String</th><th>String</th></tr></thead><tbody><p>4 rows √ó 9 columns</p><tr><th>1</th><td>œÑ</td><td>2.60875e11</td><td>s</td><td>yr</td><td>NaN</td><td>NaN</td><td>false</td><td></td><td></td></tr><tr><th>2</th><td>Œª</td><td>1.5844e-7</td><td>m s^-1</td><td>m yr^-1</td><td>NaN</td><td>NaN</td><td>false</td><td></td><td></td></tr><tr><th>3</th><td>h</td><td>200.0</td><td>m</td><td>m</td><td>NaN</td><td>NaN</td><td>false</td><td></td><td></td></tr><tr><th>4</th><td>Ratm</td><td>1.0</td><td>mol m^-3</td><td>mol m^-3</td><td>NaN</td><td>NaN</td><td>false</td><td></td><td></td></tr></tbody></table><p>shows the parameters that you just created.</p><p>We now generate a new object to contain all these parameters via</p><pre><code class="language-">initialize_Parameters_type(t, &quot;C14_shoebox_parameters&quot;) # creates the type for parameters
p = C14_shoebox_parameters()                            # creates the parameters object</code></pre><h4><a class="nav-anchor" id="Generate-the-state-function-and-its-Jacobian-1" href="#Generate-the-state-function-and-its-Jacobian-1">Generate the state function and its Jacobian</a></h4><p>The last step for the setup is for AIBECS to create <span>$\boldsymbol{F}(\boldsymbol{x}, \boldsymbol{p}) = \boldsymbol{G}(\boldsymbol{x}, \boldsymbol{p}) - \mathbf{T}(\boldsymbol{p}) \, \boldsymbol{x}$</span>, which defines the rate of change of the state, <span>$\boldsymbol{x}$</span>. This is done via</p><pre><code class="language-">F, ‚àá‚ÇìF = state_function_and_Jacobian(p -&gt; T, G) # generates the state function (and its Jacobian!)
x = zeros(nb)
F(x,p)</code></pre><p>Note here that AIBECS has automatically created <code>‚àá‚ÇìF</code>, i.e., <span>$\nabla_{\boldsymbol{x}}\boldsymbol{F}(\boldsymbol{x}, \boldsymbol{p})$</span>, which is the Jacobian of the system. This Jacobian will be useful in the simulations below.</p><p>That&#39;s it! Your model is entirely setup and ready to be used for simulations!</p><h2><a class="nav-anchor" id="Time-stepping-1" href="#Time-stepping-1">Time stepping</a></h2><p>One way to see how the tracer evolves with time is to time step it. Here we will use the <a href="https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method">Crank-Nicolson</a> scheme embedded in AIBECS.</p><p>A single step is performed via, e.g.,</p><pre><code class="language-">Œ¥t = ustrip(1.0u&quot;yr&quot; |&gt; u&quot;s&quot;)
AIBECS.crank_nicolson_step(x, p, Œ¥t, F, ‚àá‚ÇìF)</code></pre><p>We can write a function to run all the time steps and save them into a <code>x_hist</code> object, via</p><pre><code class="language-julia">function time_steps(x‚ÇÄ, Œît, n, F, ‚àá‚ÇìF)
    x_hist = [x‚ÇÄ]
    Œ¥t = Œît / n
    for i in 1:n
        push!(x_hist, AIBECS.crank_nicolson_step(last(x_hist), p, Œ¥t, F, ‚àá‚ÇìF))
    end
    return reduce(hcat, x_hist), 0:Œ¥t:Œît
end</code></pre><pre><code class="language-none">time_steps (generic function with 1 method)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>We store all the history of <code>x</code> in <code>x_hist</code>. At each step, the <code>push!</code> function adds a new <code>x</code> to <code>x_hist</code>. Technically, <code>x_hist</code> is a vector of vectors, so at the end, we horizontally concatenate it via <code>reduce(hcat, x_hist)</code> to rearrange it into a 2D array.</p></div></div><p>Now let&#39;s simulate the evolution of radiocarbon for 7500 years, starting from a concentration of 1 everywhere, via</p><pre><code class="language-">Œît = ustrip(7500u&quot;yr&quot; |&gt; u&quot;s&quot;) # 7500 years in seconds
x‚ÇÄ = ones(5)             #
x_hist, t_hist = time_steps(x‚ÇÄ, Œît, 1000, F, ‚àá‚ÇìF) # runs the simulation</code></pre><p>This should take a few seconds to run.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>AIBECS also has other time-stepping methods available, including Euler-froward (fast but unstable), Euler-backwards (like Crank-Nicolson, slow but stable), and Crank-Nicolson-Leapfrog (Fast-ish and more stable than Euler forward).</p></div></div><p>Once it&#39;s done, we can plot the evolution of radiocarbon through time via</p><pre><code class="language-">using PyPlot
clf()
C14age_hist = -log.(x_hist) * ustrip(p.œÑ * u&quot;s&quot; |&gt; u&quot;yr&quot;)
plot(t_hist * ustrip(1u&quot;s&quot; |&gt; u&quot;yr&quot;), C14age_hist&#39;)
xlabel(&quot;simulation time (years)&quot;)
ylabel(&quot;¬π‚Å¥C age (years)&quot;)
legend(&quot;box &quot; .* string.(iwet))
title(&quot;Simulation of the evolution of ¬π‚Å¥C age with Crank-Nicolson time steps&quot;)
gcf()</code></pre><p>The box model took more than 4000 years to spin up to equilibrium. For a box model that&#39;s no big deal because it is not computationally expensive to run the model, but for a big circulation model waiting for the model to spinup is painfully long. We therefore want a better way to find the equilibrium solution.</p><h2><a class="nav-anchor" id="Solving-Directly-for-the-Steady-State-1" href="#Solving-Directly-for-the-Steady-State-1">Solving Directly for the Steady State</a></h2><p>With the AIBECS, you can create the steady state problem and solve it in just 2 commands:</p><pre><code class="language-">prob = SteadyStateProblem(F, ‚àá‚ÇìF, x, p)
x_final = solve(prob, CTKAlg()).u</code></pre><p>Converting radiocarbon into years gives the following values</p><pre><code class="language-">C14age_final = -log.(x_final) * p.œÑ * u&quot;s&quot; .|&gt; u&quot;yr&quot;
println.(&quot;box &quot;, iwet, &quot;: &quot;, C14age_final);</code></pre><p>These are exactly the limit that the Radiocarbon age reaches after about 4000 years of simulation! So what happened there?</p><p>Well, AIBECS used a version of <a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton&#39;s method</a> to solve for <span>$\boldsymbol{F}(\boldsymbol{x}, \boldsymbol{p}) = 0$</span>. Simply put, Newton&#39;s method iterates on the state via the recursion relation</p><div>\[\boldsymbol{x}_{n+1} = \boldsymbol{x}_n - \nabla_{\boldsymbol{x}}\boldsymbol{F}(\boldsymbol{x}, \boldsymbol{p})^{-1} \boldsymbol{F}(\boldsymbol{x}, \boldsymbol{p}).\]</div><p>Here, our radiocarbon model only requires a single iteration. This is because the state function, <span>$\boldsymbol{F}(\boldsymbol{x}, \boldsymbol{p})$</span>, is linear.</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../radiocarbon_OCIM/"><span class="direction">Previous</span><span class="title">Radiocarbon with OCIM1</span></a><a class="next" href="../../../functions/"><span class="direction">Next</span><span class="title">Function index</span></a></footer></article></body></html>
